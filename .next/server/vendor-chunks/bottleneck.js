/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bottleneck";
exports.ids = ["vendor-chunks/bottleneck"];
exports.modules = {

/***/ "(ssr)/./node_modules/bottleneck/light.js":
/*!******************************************!*\
  !*** ./node_modules/bottleneck/light.js ***!
  \******************************************/
/***/ (function(module) {

eval("/**\n  * This file contains the Bottleneck library (MIT), compiled to ES2017, and without Clustering support.\n  * https://github.com/SGrondin/bottleneck\n  */\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n['default'] || n;\n\t}\n\n\tvar load = function(received, defaults, onto = {}) {\n\t  var k, ref, v;\n\t  for (k in defaults) {\n\t    v = defaults[k];\n\t    onto[k] = (ref = received[k]) != null ? ref : v;\n\t  }\n\t  return onto;\n\t};\n\n\tvar overwrite = function(received, defaults, onto = {}) {\n\t  var k, v;\n\t  for (k in received) {\n\t    v = received[k];\n\t    if (defaults[k] !== void 0) {\n\t      onto[k] = v;\n\t    }\n\t  }\n\t  return onto;\n\t};\n\n\tvar parser = {\n\t\tload: load,\n\t\toverwrite: overwrite\n\t};\n\n\tvar DLList;\n\n\tDLList = class DLList {\n\t  constructor(incr, decr) {\n\t    this.incr = incr;\n\t    this.decr = decr;\n\t    this._first = null;\n\t    this._last = null;\n\t    this.length = 0;\n\t  }\n\n\t  push(value) {\n\t    var node;\n\t    this.length++;\n\t    if (typeof this.incr === \"function\") {\n\t      this.incr();\n\t    }\n\t    node = {\n\t      value,\n\t      prev: this._last,\n\t      next: null\n\t    };\n\t    if (this._last != null) {\n\t      this._last.next = node;\n\t      this._last = node;\n\t    } else {\n\t      this._first = this._last = node;\n\t    }\n\t    return void 0;\n\t  }\n\n\t  shift() {\n\t    var value;\n\t    if (this._first == null) {\n\t      return;\n\t    } else {\n\t      this.length--;\n\t      if (typeof this.decr === \"function\") {\n\t        this.decr();\n\t      }\n\t    }\n\t    value = this._first.value;\n\t    if ((this._first = this._first.next) != null) {\n\t      this._first.prev = null;\n\t    } else {\n\t      this._last = null;\n\t    }\n\t    return value;\n\t  }\n\n\t  first() {\n\t    if (this._first != null) {\n\t      return this._first.value;\n\t    }\n\t  }\n\n\t  getArray() {\n\t    var node, ref, results;\n\t    node = this._first;\n\t    results = [];\n\t    while (node != null) {\n\t      results.push((ref = node, node = node.next, ref.value));\n\t    }\n\t    return results;\n\t  }\n\n\t  forEachShift(cb) {\n\t    var node;\n\t    node = this.shift();\n\t    while (node != null) {\n\t      (cb(node), node = this.shift());\n\t    }\n\t    return void 0;\n\t  }\n\n\t  debug() {\n\t    var node, ref, ref1, ref2, results;\n\t    node = this._first;\n\t    results = [];\n\t    while (node != null) {\n\t      results.push((ref = node, node = node.next, {\n\t        value: ref.value,\n\t        prev: (ref1 = ref.prev) != null ? ref1.value : void 0,\n\t        next: (ref2 = ref.next) != null ? ref2.value : void 0\n\t      }));\n\t    }\n\t    return results;\n\t  }\n\n\t};\n\n\tvar DLList_1 = DLList;\n\n\tvar Events;\n\n\tEvents = class Events {\n\t  constructor(instance) {\n\t    this.instance = instance;\n\t    this._events = {};\n\t    if ((this.instance.on != null) || (this.instance.once != null) || (this.instance.removeAllListeners != null)) {\n\t      throw new Error(\"An Emitter already exists for this object\");\n\t    }\n\t    this.instance.on = (name, cb) => {\n\t      return this._addListener(name, \"many\", cb);\n\t    };\n\t    this.instance.once = (name, cb) => {\n\t      return this._addListener(name, \"once\", cb);\n\t    };\n\t    this.instance.removeAllListeners = (name = null) => {\n\t      if (name != null) {\n\t        return delete this._events[name];\n\t      } else {\n\t        return this._events = {};\n\t      }\n\t    };\n\t  }\n\n\t  _addListener(name, status, cb) {\n\t    var base;\n\t    if ((base = this._events)[name] == null) {\n\t      base[name] = [];\n\t    }\n\t    this._events[name].push({cb, status});\n\t    return this.instance;\n\t  }\n\n\t  listenerCount(name) {\n\t    if (this._events[name] != null) {\n\t      return this._events[name].length;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\n\t  async trigger(name, ...args) {\n\t    var e, promises;\n\t    try {\n\t      if (name !== \"debug\") {\n\t        this.trigger(\"debug\", `Event triggered: ${name}`, args);\n\t      }\n\t      if (this._events[name] == null) {\n\t        return;\n\t      }\n\t      this._events[name] = this._events[name].filter(function(listener) {\n\t        return listener.status !== \"none\";\n\t      });\n\t      promises = this._events[name].map(async(listener) => {\n\t        var e, returned;\n\t        if (listener.status === \"none\") {\n\t          return;\n\t        }\n\t        if (listener.status === \"once\") {\n\t          listener.status = \"none\";\n\t        }\n\t        try {\n\t          returned = typeof listener.cb === \"function\" ? listener.cb(...args) : void 0;\n\t          if (typeof (returned != null ? returned.then : void 0) === \"function\") {\n\t            return (await returned);\n\t          } else {\n\t            return returned;\n\t          }\n\t        } catch (error) {\n\t          e = error;\n\t          {\n\t            this.trigger(\"error\", e);\n\t          }\n\t          return null;\n\t        }\n\t      });\n\t      return ((await Promise.all(promises))).find(function(x) {\n\t        return x != null;\n\t      });\n\t    } catch (error) {\n\t      e = error;\n\t      {\n\t        this.trigger(\"error\", e);\n\t      }\n\t      return null;\n\t    }\n\t  }\n\n\t};\n\n\tvar Events_1 = Events;\n\n\tvar DLList$1, Events$1, Queues;\n\n\tDLList$1 = DLList_1;\n\n\tEvents$1 = Events_1;\n\n\tQueues = class Queues {\n\t  constructor(num_priorities) {\n\t    var i;\n\t    this.Events = new Events$1(this);\n\t    this._length = 0;\n\t    this._lists = (function() {\n\t      var j, ref, results;\n\t      results = [];\n\t      for (i = j = 1, ref = num_priorities; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {\n\t        results.push(new DLList$1((() => {\n\t          return this.incr();\n\t        }), (() => {\n\t          return this.decr();\n\t        })));\n\t      }\n\t      return results;\n\t    }).call(this);\n\t  }\n\n\t  incr() {\n\t    if (this._length++ === 0) {\n\t      return this.Events.trigger(\"leftzero\");\n\t    }\n\t  }\n\n\t  decr() {\n\t    if (--this._length === 0) {\n\t      return this.Events.trigger(\"zero\");\n\t    }\n\t  }\n\n\t  push(job) {\n\t    return this._lists[job.options.priority].push(job);\n\t  }\n\n\t  queued(priority) {\n\t    if (priority != null) {\n\t      return this._lists[priority].length;\n\t    } else {\n\t      return this._length;\n\t    }\n\t  }\n\n\t  shiftAll(fn) {\n\t    return this._lists.forEach(function(list) {\n\t      return list.forEachShift(fn);\n\t    });\n\t  }\n\n\t  getFirst(arr = this._lists) {\n\t    var j, len, list;\n\t    for (j = 0, len = arr.length; j < len; j++) {\n\t      list = arr[j];\n\t      if (list.length > 0) {\n\t        return list;\n\t      }\n\t    }\n\t    return [];\n\t  }\n\n\t  shiftLastFrom(priority) {\n\t    return this.getFirst(this._lists.slice(priority).reverse()).shift();\n\t  }\n\n\t};\n\n\tvar Queues_1 = Queues;\n\n\tvar BottleneckError;\n\n\tBottleneckError = class BottleneckError extends Error {};\n\n\tvar BottleneckError_1 = BottleneckError;\n\n\tvar BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;\n\n\tNUM_PRIORITIES = 10;\n\n\tDEFAULT_PRIORITY = 5;\n\n\tparser$1 = parser;\n\n\tBottleneckError$1 = BottleneckError_1;\n\n\tJob = class Job {\n\t  constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise) {\n\t    this.task = task;\n\t    this.args = args;\n\t    this.rejectOnDrop = rejectOnDrop;\n\t    this.Events = Events;\n\t    this._states = _states;\n\t    this.Promise = Promise;\n\t    this.options = parser$1.load(options, jobDefaults);\n\t    this.options.priority = this._sanitizePriority(this.options.priority);\n\t    if (this.options.id === jobDefaults.id) {\n\t      this.options.id = `${this.options.id}-${this._randomIndex()}`;\n\t    }\n\t    this.promise = new this.Promise((_resolve, _reject) => {\n\t      this._resolve = _resolve;\n\t      this._reject = _reject;\n\t    });\n\t    this.retryCount = 0;\n\t  }\n\n\t  _sanitizePriority(priority) {\n\t    var sProperty;\n\t    sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;\n\t    if (sProperty < 0) {\n\t      return 0;\n\t    } else if (sProperty > NUM_PRIORITIES - 1) {\n\t      return NUM_PRIORITIES - 1;\n\t    } else {\n\t      return sProperty;\n\t    }\n\t  }\n\n\t  _randomIndex() {\n\t    return Math.random().toString(36).slice(2);\n\t  }\n\n\t  doDrop({error, message = \"This job has been dropped by Bottleneck\"} = {}) {\n\t    if (this._states.remove(this.options.id)) {\n\t      if (this.rejectOnDrop) {\n\t        this._reject(error != null ? error : new BottleneckError$1(message));\n\t      }\n\t      this.Events.trigger(\"dropped\", {args: this.args, options: this.options, task: this.task, promise: this.promise});\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\n\t  _assertStatus(expected) {\n\t    var status;\n\t    status = this._states.jobStatus(this.options.id);\n\t    if (!(status === expected || (expected === \"DONE\" && status === null))) {\n\t      throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);\n\t    }\n\t  }\n\n\t  doReceive() {\n\t    this._states.start(this.options.id);\n\t    return this.Events.trigger(\"received\", {args: this.args, options: this.options});\n\t  }\n\n\t  doQueue(reachedHWM, blocked) {\n\t    this._assertStatus(\"RECEIVED\");\n\t    this._states.next(this.options.id);\n\t    return this.Events.trigger(\"queued\", {args: this.args, options: this.options, reachedHWM, blocked});\n\t  }\n\n\t  doRun() {\n\t    if (this.retryCount === 0) {\n\t      this._assertStatus(\"QUEUED\");\n\t      this._states.next(this.options.id);\n\t    } else {\n\t      this._assertStatus(\"EXECUTING\");\n\t    }\n\t    return this.Events.trigger(\"scheduled\", {args: this.args, options: this.options});\n\t  }\n\n\t  async doExecute(chained, clearGlobalState, run, free) {\n\t    var error, eventInfo, passed;\n\t    if (this.retryCount === 0) {\n\t      this._assertStatus(\"RUNNING\");\n\t      this._states.next(this.options.id);\n\t    } else {\n\t      this._assertStatus(\"EXECUTING\");\n\t    }\n\t    eventInfo = {args: this.args, options: this.options, retryCount: this.retryCount};\n\t    this.Events.trigger(\"executing\", eventInfo);\n\t    try {\n\t      passed = (await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args)));\n\t      if (clearGlobalState()) {\n\t        this.doDone(eventInfo);\n\t        await free(this.options, eventInfo);\n\t        this._assertStatus(\"DONE\");\n\t        return this._resolve(passed);\n\t      }\n\t    } catch (error1) {\n\t      error = error1;\n\t      return this._onFailure(error, eventInfo, clearGlobalState, run, free);\n\t    }\n\t  }\n\n\t  doExpire(clearGlobalState, run, free) {\n\t    var error, eventInfo;\n\t    if (this._states.jobStatus(this.options.id === \"RUNNING\")) {\n\t      this._states.next(this.options.id);\n\t    }\n\t    this._assertStatus(\"EXECUTING\");\n\t    eventInfo = {args: this.args, options: this.options, retryCount: this.retryCount};\n\t    error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);\n\t    return this._onFailure(error, eventInfo, clearGlobalState, run, free);\n\t  }\n\n\t  async _onFailure(error, eventInfo, clearGlobalState, run, free) {\n\t    var retry, retryAfter;\n\t    if (clearGlobalState()) {\n\t      retry = (await this.Events.trigger(\"failed\", error, eventInfo));\n\t      if (retry != null) {\n\t        retryAfter = ~~retry;\n\t        this.Events.trigger(\"retry\", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);\n\t        this.retryCount++;\n\t        return run(retryAfter);\n\t      } else {\n\t        this.doDone(eventInfo);\n\t        await free(this.options, eventInfo);\n\t        this._assertStatus(\"DONE\");\n\t        return this._reject(error);\n\t      }\n\t    }\n\t  }\n\n\t  doDone(eventInfo) {\n\t    this._assertStatus(\"EXECUTING\");\n\t    this._states.next(this.options.id);\n\t    return this.Events.trigger(\"done\", eventInfo);\n\t  }\n\n\t};\n\n\tvar Job_1 = Job;\n\n\tvar BottleneckError$2, LocalDatastore, parser$2;\n\n\tparser$2 = parser;\n\n\tBottleneckError$2 = BottleneckError_1;\n\n\tLocalDatastore = class LocalDatastore {\n\t  constructor(instance, storeOptions, storeInstanceOptions) {\n\t    this.instance = instance;\n\t    this.storeOptions = storeOptions;\n\t    this.clientId = this.instance._randomIndex();\n\t    parser$2.load(storeInstanceOptions, storeInstanceOptions, this);\n\t    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n\t    this._running = 0;\n\t    this._done = 0;\n\t    this._unblockTime = 0;\n\t    this.ready = this.Promise.resolve();\n\t    this.clients = {};\n\t    this._startHeartbeat();\n\t  }\n\n\t  _startHeartbeat() {\n\t    var base;\n\t    if ((this.heartbeat == null) && (((this.storeOptions.reservoirRefreshInterval != null) && (this.storeOptions.reservoirRefreshAmount != null)) || ((this.storeOptions.reservoirIncreaseInterval != null) && (this.storeOptions.reservoirIncreaseAmount != null)))) {\n\t      return typeof (base = (this.heartbeat = setInterval(() => {\n\t        var amount, incr, maximum, now, reservoir;\n\t        now = Date.now();\n\t        if ((this.storeOptions.reservoirRefreshInterval != null) && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\n\t          this._lastReservoirRefresh = now;\n\t          this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\n\t          this.instance._drainAll(this.computeCapacity());\n\t        }\n\t        if ((this.storeOptions.reservoirIncreaseInterval != null) && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\n\t          ({\n\t            reservoirIncreaseAmount: amount,\n\t            reservoirIncreaseMaximum: maximum,\n\t            reservoir\n\t          } = this.storeOptions);\n\t          this._lastReservoirIncrease = now;\n\t          incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n\t          if (incr > 0) {\n\t            this.storeOptions.reservoir += incr;\n\t            return this.instance._drainAll(this.computeCapacity());\n\t          }\n\t        }\n\t      }, this.heartbeatInterval))).unref === \"function\" ? base.unref() : void 0;\n\t    } else {\n\t      return clearInterval(this.heartbeat);\n\t    }\n\t  }\n\n\t  async __publish__(message) {\n\t    await this.yieldLoop();\n\t    return this.instance.Events.trigger(\"message\", message.toString());\n\t  }\n\n\t  async __disconnect__(flush) {\n\t    await this.yieldLoop();\n\t    clearInterval(this.heartbeat);\n\t    return this.Promise.resolve();\n\t  }\n\n\t  yieldLoop(t = 0) {\n\t    return new this.Promise(function(resolve, reject) {\n\t      return setTimeout(resolve, t);\n\t    });\n\t  }\n\n\t  computePenalty() {\n\t    var ref;\n\t    return (ref = this.storeOptions.penalty) != null ? ref : (15 * this.storeOptions.minTime) || 5000;\n\t  }\n\n\t  async __updateSettings__(options) {\n\t    await this.yieldLoop();\n\t    parser$2.overwrite(options, options, this.storeOptions);\n\t    this._startHeartbeat();\n\t    this.instance._drainAll(this.computeCapacity());\n\t    return true;\n\t  }\n\n\t  async __running__() {\n\t    await this.yieldLoop();\n\t    return this._running;\n\t  }\n\n\t  async __queued__() {\n\t    await this.yieldLoop();\n\t    return this.instance.queued();\n\t  }\n\n\t  async __done__() {\n\t    await this.yieldLoop();\n\t    return this._done;\n\t  }\n\n\t  async __groupCheck__(time) {\n\t    await this.yieldLoop();\n\t    return (this._nextRequest + this.timeout) < time;\n\t  }\n\n\t  computeCapacity() {\n\t    var maxConcurrent, reservoir;\n\t    ({maxConcurrent, reservoir} = this.storeOptions);\n\t    if ((maxConcurrent != null) && (reservoir != null)) {\n\t      return Math.min(maxConcurrent - this._running, reservoir);\n\t    } else if (maxConcurrent != null) {\n\t      return maxConcurrent - this._running;\n\t    } else if (reservoir != null) {\n\t      return reservoir;\n\t    } else {\n\t      return null;\n\t    }\n\t  }\n\n\t  conditionsCheck(weight) {\n\t    var capacity;\n\t    capacity = this.computeCapacity();\n\t    return (capacity == null) || weight <= capacity;\n\t  }\n\n\t  async __incrementReservoir__(incr) {\n\t    var reservoir;\n\t    await this.yieldLoop();\n\t    reservoir = this.storeOptions.reservoir += incr;\n\t    this.instance._drainAll(this.computeCapacity());\n\t    return reservoir;\n\t  }\n\n\t  async __currentReservoir__() {\n\t    await this.yieldLoop();\n\t    return this.storeOptions.reservoir;\n\t  }\n\n\t  isBlocked(now) {\n\t    return this._unblockTime >= now;\n\t  }\n\n\t  check(weight, now) {\n\t    return this.conditionsCheck(weight) && (this._nextRequest - now) <= 0;\n\t  }\n\n\t  async __check__(weight) {\n\t    var now;\n\t    await this.yieldLoop();\n\t    now = Date.now();\n\t    return this.check(weight, now);\n\t  }\n\n\t  async __register__(index, weight, expiration) {\n\t    var now, wait;\n\t    await this.yieldLoop();\n\t    now = Date.now();\n\t    if (this.conditionsCheck(weight)) {\n\t      this._running += weight;\n\t      if (this.storeOptions.reservoir != null) {\n\t        this.storeOptions.reservoir -= weight;\n\t      }\n\t      wait = Math.max(this._nextRequest - now, 0);\n\t      this._nextRequest = now + wait + this.storeOptions.minTime;\n\t      return {\n\t        success: true,\n\t        wait,\n\t        reservoir: this.storeOptions.reservoir\n\t      };\n\t    } else {\n\t      return {\n\t        success: false\n\t      };\n\t    }\n\t  }\n\n\t  strategyIsBlock() {\n\t    return this.storeOptions.strategy === 3;\n\t  }\n\n\t  async __submit__(queueLength, weight) {\n\t    var blocked, now, reachedHWM;\n\t    await this.yieldLoop();\n\t    if ((this.storeOptions.maxConcurrent != null) && weight > this.storeOptions.maxConcurrent) {\n\t      throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);\n\t    }\n\t    now = Date.now();\n\t    reachedHWM = (this.storeOptions.highWater != null) && queueLength === this.storeOptions.highWater && !this.check(weight, now);\n\t    blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));\n\t    if (blocked) {\n\t      this._unblockTime = now + this.computePenalty();\n\t      this._nextRequest = this._unblockTime + this.storeOptions.minTime;\n\t      this.instance._dropAllQueued();\n\t    }\n\t    return {\n\t      reachedHWM,\n\t      blocked,\n\t      strategy: this.storeOptions.strategy\n\t    };\n\t  }\n\n\t  async __free__(index, weight) {\n\t    await this.yieldLoop();\n\t    this._running -= weight;\n\t    this._done += weight;\n\t    this.instance._drainAll(this.computeCapacity());\n\t    return {\n\t      running: this._running\n\t    };\n\t  }\n\n\t};\n\n\tvar LocalDatastore_1 = LocalDatastore;\n\n\tvar BottleneckError$3, States;\n\n\tBottleneckError$3 = BottleneckError_1;\n\n\tStates = class States {\n\t  constructor(status1) {\n\t    this.status = status1;\n\t    this._jobs = {};\n\t    this.counts = this.status.map(function() {\n\t      return 0;\n\t    });\n\t  }\n\n\t  next(id) {\n\t    var current, next;\n\t    current = this._jobs[id];\n\t    next = current + 1;\n\t    if ((current != null) && next < this.status.length) {\n\t      this.counts[current]--;\n\t      this.counts[next]++;\n\t      return this._jobs[id]++;\n\t    } else if (current != null) {\n\t      this.counts[current]--;\n\t      return delete this._jobs[id];\n\t    }\n\t  }\n\n\t  start(id) {\n\t    var initial;\n\t    initial = 0;\n\t    this._jobs[id] = initial;\n\t    return this.counts[initial]++;\n\t  }\n\n\t  remove(id) {\n\t    var current;\n\t    current = this._jobs[id];\n\t    if (current != null) {\n\t      this.counts[current]--;\n\t      delete this._jobs[id];\n\t    }\n\t    return current != null;\n\t  }\n\n\t  jobStatus(id) {\n\t    var ref;\n\t    return (ref = this.status[this._jobs[id]]) != null ? ref : null;\n\t  }\n\n\t  statusJobs(status) {\n\t    var k, pos, ref, results, v;\n\t    if (status != null) {\n\t      pos = this.status.indexOf(status);\n\t      if (pos < 0) {\n\t        throw new BottleneckError$3(`status must be one of ${this.status.join(', ')}`);\n\t      }\n\t      ref = this._jobs;\n\t      results = [];\n\t      for (k in ref) {\n\t        v = ref[k];\n\t        if (v === pos) {\n\t          results.push(k);\n\t        }\n\t      }\n\t      return results;\n\t    } else {\n\t      return Object.keys(this._jobs);\n\t    }\n\t  }\n\n\t  statusCounts() {\n\t    return this.counts.reduce(((acc, v, i) => {\n\t      acc[this.status[i]] = v;\n\t      return acc;\n\t    }), {});\n\t  }\n\n\t};\n\n\tvar States_1 = States;\n\n\tvar DLList$2, Sync;\n\n\tDLList$2 = DLList_1;\n\n\tSync = class Sync {\n\t  constructor(name, Promise) {\n\t    this.schedule = this.schedule.bind(this);\n\t    this.name = name;\n\t    this.Promise = Promise;\n\t    this._running = 0;\n\t    this._queue = new DLList$2();\n\t  }\n\n\t  isEmpty() {\n\t    return this._queue.length === 0;\n\t  }\n\n\t  async _tryToRun() {\n\t    var args, cb, error, reject, resolve, returned, task;\n\t    if ((this._running < 1) && this._queue.length > 0) {\n\t      this._running++;\n\t      ({task, args, resolve, reject} = this._queue.shift());\n\t      cb = (await (async function() {\n\t        try {\n\t          returned = (await task(...args));\n\t          return function() {\n\t            return resolve(returned);\n\t          };\n\t        } catch (error1) {\n\t          error = error1;\n\t          return function() {\n\t            return reject(error);\n\t          };\n\t        }\n\t      })());\n\t      this._running--;\n\t      this._tryToRun();\n\t      return cb();\n\t    }\n\t  }\n\n\t  schedule(task, ...args) {\n\t    var promise, reject, resolve;\n\t    resolve = reject = null;\n\t    promise = new this.Promise(function(_resolve, _reject) {\n\t      resolve = _resolve;\n\t      return reject = _reject;\n\t    });\n\t    this._queue.push({task, args, resolve, reject});\n\t    this._tryToRun();\n\t    return promise;\n\t  }\n\n\t};\n\n\tvar Sync_1 = Sync;\n\n\tvar version = \"2.19.5\";\n\tvar version$1 = {\n\t\tversion: version\n\t};\n\n\tvar version$2 = /*#__PURE__*/Object.freeze({\n\t\tversion: version,\n\t\tdefault: version$1\n\t});\n\n\tvar require$$2 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar require$$3 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar require$$4 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;\n\n\tparser$3 = parser;\n\n\tEvents$2 = Events_1;\n\n\tRedisConnection$1 = require$$2;\n\n\tIORedisConnection$1 = require$$3;\n\n\tScripts$1 = require$$4;\n\n\tGroup = (function() {\n\t  class Group {\n\t    constructor(limiterOptions = {}) {\n\t      this.deleteKey = this.deleteKey.bind(this);\n\t      this.limiterOptions = limiterOptions;\n\t      parser$3.load(this.limiterOptions, this.defaults, this);\n\t      this.Events = new Events$2(this);\n\t      this.instances = {};\n\t      this.Bottleneck = Bottleneck_1;\n\t      this._startAutoCleanup();\n\t      this.sharedConnection = this.connection != null;\n\t      if (this.connection == null) {\n\t        if (this.limiterOptions.datastore === \"redis\") {\n\t          this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, {Events: this.Events}));\n\t        } else if (this.limiterOptions.datastore === \"ioredis\") {\n\t          this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, {Events: this.Events}));\n\t        }\n\t      }\n\t    }\n\n\t    key(key = \"\") {\n\t      var ref;\n\t      return (ref = this.instances[key]) != null ? ref : (() => {\n\t        var limiter;\n\t        limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {\n\t          id: `${this.id}-${key}`,\n\t          timeout: this.timeout,\n\t          connection: this.connection\n\t        }));\n\t        this.Events.trigger(\"created\", limiter, key);\n\t        return limiter;\n\t      })();\n\t    }\n\n\t    async deleteKey(key = \"\") {\n\t      var deleted, instance;\n\t      instance = this.instances[key];\n\t      if (this.connection) {\n\t        deleted = (await this.connection.__runCommand__(['del', ...Scripts$1.allKeys(`${this.id}-${key}`)]));\n\t      }\n\t      if (instance != null) {\n\t        delete this.instances[key];\n\t        await instance.disconnect();\n\t      }\n\t      return (instance != null) || deleted > 0;\n\t    }\n\n\t    limiters() {\n\t      var k, ref, results, v;\n\t      ref = this.instances;\n\t      results = [];\n\t      for (k in ref) {\n\t        v = ref[k];\n\t        results.push({\n\t          key: k,\n\t          limiter: v\n\t        });\n\t      }\n\t      return results;\n\t    }\n\n\t    keys() {\n\t      return Object.keys(this.instances);\n\t    }\n\n\t    async clusterKeys() {\n\t      var cursor, end, found, i, k, keys, len, next, start;\n\t      if (this.connection == null) {\n\t        return this.Promise.resolve(this.keys());\n\t      }\n\t      keys = [];\n\t      cursor = null;\n\t      start = `b_${this.id}-`.length;\n\t      end = \"_settings\".length;\n\t      while (cursor !== 0) {\n\t        [next, found] = (await this.connection.__runCommand__([\"scan\", cursor != null ? cursor : 0, \"match\", `b_${this.id}-*_settings`, \"count\", 10000]));\n\t        cursor = ~~next;\n\t        for (i = 0, len = found.length; i < len; i++) {\n\t          k = found[i];\n\t          keys.push(k.slice(start, -end));\n\t        }\n\t      }\n\t      return keys;\n\t    }\n\n\t    _startAutoCleanup() {\n\t      var base;\n\t      clearInterval(this.interval);\n\t      return typeof (base = (this.interval = setInterval(async() => {\n\t        var e, k, ref, results, time, v;\n\t        time = Date.now();\n\t        ref = this.instances;\n\t        results = [];\n\t        for (k in ref) {\n\t          v = ref[k];\n\t          try {\n\t            if ((await v._store.__groupCheck__(time))) {\n\t              results.push(this.deleteKey(k));\n\t            } else {\n\t              results.push(void 0);\n\t            }\n\t          } catch (error) {\n\t            e = error;\n\t            results.push(v.Events.trigger(\"error\", e));\n\t          }\n\t        }\n\t        return results;\n\t      }, this.timeout / 2))).unref === \"function\" ? base.unref() : void 0;\n\t    }\n\n\t    updateSettings(options = {}) {\n\t      parser$3.overwrite(options, this.defaults, this);\n\t      parser$3.overwrite(options, options, this.limiterOptions);\n\t      if (options.timeout != null) {\n\t        return this._startAutoCleanup();\n\t      }\n\t    }\n\n\t    disconnect(flush = true) {\n\t      var ref;\n\t      if (!this.sharedConnection) {\n\t        return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;\n\t      }\n\t    }\n\n\t  }\n\t  Group.prototype.defaults = {\n\t    timeout: 1000 * 60 * 5,\n\t    connection: null,\n\t    Promise: Promise,\n\t    id: \"group-key\"\n\t  };\n\n\t  return Group;\n\n\t}).call(commonjsGlobal);\n\n\tvar Group_1 = Group;\n\n\tvar Batcher, Events$3, parser$4;\n\n\tparser$4 = parser;\n\n\tEvents$3 = Events_1;\n\n\tBatcher = (function() {\n\t  class Batcher {\n\t    constructor(options = {}) {\n\t      this.options = options;\n\t      parser$4.load(this.options, this.defaults, this);\n\t      this.Events = new Events$3(this);\n\t      this._arr = [];\n\t      this._resetPromise();\n\t      this._lastFlush = Date.now();\n\t    }\n\n\t    _resetPromise() {\n\t      return this._promise = new this.Promise((res, rej) => {\n\t        return this._resolve = res;\n\t      });\n\t    }\n\n\t    _flush() {\n\t      clearTimeout(this._timeout);\n\t      this._lastFlush = Date.now();\n\t      this._resolve();\n\t      this.Events.trigger(\"batch\", this._arr);\n\t      this._arr = [];\n\t      return this._resetPromise();\n\t    }\n\n\t    add(data) {\n\t      var ret;\n\t      this._arr.push(data);\n\t      ret = this._promise;\n\t      if (this._arr.length === this.maxSize) {\n\t        this._flush();\n\t      } else if ((this.maxTime != null) && this._arr.length === 1) {\n\t        this._timeout = setTimeout(() => {\n\t          return this._flush();\n\t        }, this.maxTime);\n\t      }\n\t      return ret;\n\t    }\n\n\t  }\n\t  Batcher.prototype.defaults = {\n\t    maxTime: null,\n\t    maxSize: null,\n\t    Promise: Promise\n\t  };\n\n\t  return Batcher;\n\n\t}).call(commonjsGlobal);\n\n\tvar Batcher_1 = Batcher;\n\n\tvar require$$4$1 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar require$$8 = getCjsExportFromNamespace(version$2);\n\n\tvar Bottleneck, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5,\n\t  splice = [].splice;\n\n\tNUM_PRIORITIES$1 = 10;\n\n\tDEFAULT_PRIORITY$1 = 5;\n\n\tparser$5 = parser;\n\n\tQueues$1 = Queues_1;\n\n\tJob$1 = Job_1;\n\n\tLocalDatastore$1 = LocalDatastore_1;\n\n\tRedisDatastore$1 = require$$4$1;\n\n\tEvents$4 = Events_1;\n\n\tStates$1 = States_1;\n\n\tSync$1 = Sync_1;\n\n\tBottleneck = (function() {\n\t  class Bottleneck {\n\t    constructor(options = {}, ...invalid) {\n\t      var storeInstanceOptions, storeOptions;\n\t      this._addToQueue = this._addToQueue.bind(this);\n\t      this._validateOptions(options, invalid);\n\t      parser$5.load(options, this.instanceDefaults, this);\n\t      this._queues = new Queues$1(NUM_PRIORITIES$1);\n\t      this._scheduled = {};\n\t      this._states = new States$1([\"RECEIVED\", \"QUEUED\", \"RUNNING\", \"EXECUTING\"].concat(this.trackDoneStatus ? [\"DONE\"] : []));\n\t      this._limiter = null;\n\t      this.Events = new Events$4(this);\n\t      this._submitLock = new Sync$1(\"submit\", this.Promise);\n\t      this._registerLock = new Sync$1(\"register\", this.Promise);\n\t      storeOptions = parser$5.load(options, this.storeDefaults, {});\n\t      this._store = (function() {\n\t        if (this.datastore === \"redis\" || this.datastore === \"ioredis\" || (this.connection != null)) {\n\t          storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});\n\t          return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);\n\t        } else if (this.datastore === \"local\") {\n\t          storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});\n\t          return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);\n\t        } else {\n\t          throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);\n\t        }\n\t      }).call(this);\n\t      this._queues.on(\"leftzero\", () => {\n\t        var ref;\n\t        return (ref = this._store.heartbeat) != null ? typeof ref.ref === \"function\" ? ref.ref() : void 0 : void 0;\n\t      });\n\t      this._queues.on(\"zero\", () => {\n\t        var ref;\n\t        return (ref = this._store.heartbeat) != null ? typeof ref.unref === \"function\" ? ref.unref() : void 0 : void 0;\n\t      });\n\t    }\n\n\t    _validateOptions(options, invalid) {\n\t      if (!((options != null) && typeof options === \"object\" && invalid.length === 0)) {\n\t        throw new Bottleneck.prototype.BottleneckError(\"Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.\");\n\t      }\n\t    }\n\n\t    ready() {\n\t      return this._store.ready;\n\t    }\n\n\t    clients() {\n\t      return this._store.clients;\n\t    }\n\n\t    channel() {\n\t      return `b_${this.id}`;\n\t    }\n\n\t    channel_client() {\n\t      return `b_${this.id}_${this._store.clientId}`;\n\t    }\n\n\t    publish(message) {\n\t      return this._store.__publish__(message);\n\t    }\n\n\t    disconnect(flush = true) {\n\t      return this._store.__disconnect__(flush);\n\t    }\n\n\t    chain(_limiter) {\n\t      this._limiter = _limiter;\n\t      return this;\n\t    }\n\n\t    queued(priority) {\n\t      return this._queues.queued(priority);\n\t    }\n\n\t    clusterQueued() {\n\t      return this._store.__queued__();\n\t    }\n\n\t    empty() {\n\t      return this.queued() === 0 && this._submitLock.isEmpty();\n\t    }\n\n\t    running() {\n\t      return this._store.__running__();\n\t    }\n\n\t    done() {\n\t      return this._store.__done__();\n\t    }\n\n\t    jobStatus(id) {\n\t      return this._states.jobStatus(id);\n\t    }\n\n\t    jobs(status) {\n\t      return this._states.statusJobs(status);\n\t    }\n\n\t    counts() {\n\t      return this._states.statusCounts();\n\t    }\n\n\t    _randomIndex() {\n\t      return Math.random().toString(36).slice(2);\n\t    }\n\n\t    check(weight = 1) {\n\t      return this._store.__check__(weight);\n\t    }\n\n\t    _clearGlobalState(index) {\n\t      if (this._scheduled[index] != null) {\n\t        clearTimeout(this._scheduled[index].expiration);\n\t        delete this._scheduled[index];\n\t        return true;\n\t      } else {\n\t        return false;\n\t      }\n\t    }\n\n\t    async _free(index, job, options, eventInfo) {\n\t      var e, running;\n\t      try {\n\t        ({running} = (await this._store.__free__(index, options.weight)));\n\t        this.Events.trigger(\"debug\", `Freed ${options.id}`, eventInfo);\n\t        if (running === 0 && this.empty()) {\n\t          return this.Events.trigger(\"idle\");\n\t        }\n\t      } catch (error1) {\n\t        e = error1;\n\t        return this.Events.trigger(\"error\", e);\n\t      }\n\t    }\n\n\t    _run(index, job, wait) {\n\t      var clearGlobalState, free, run;\n\t      job.doRun();\n\t      clearGlobalState = this._clearGlobalState.bind(this, index);\n\t      run = this._run.bind(this, index, job);\n\t      free = this._free.bind(this, index, job);\n\t      return this._scheduled[index] = {\n\t        timeout: setTimeout(() => {\n\t          return job.doExecute(this._limiter, clearGlobalState, run, free);\n\t        }, wait),\n\t        expiration: job.options.expiration != null ? setTimeout(function() {\n\t          return job.doExpire(clearGlobalState, run, free);\n\t        }, wait + job.options.expiration) : void 0,\n\t        job: job\n\t      };\n\t    }\n\n\t    _drainOne(capacity) {\n\t      return this._registerLock.schedule(() => {\n\t        var args, index, next, options, queue;\n\t        if (this.queued() === 0) {\n\t          return this.Promise.resolve(null);\n\t        }\n\t        queue = this._queues.getFirst();\n\t        ({options, args} = next = queue.first());\n\t        if ((capacity != null) && options.weight > capacity) {\n\t          return this.Promise.resolve(null);\n\t        }\n\t        this.Events.trigger(\"debug\", `Draining ${options.id}`, {args, options});\n\t        index = this._randomIndex();\n\t        return this._store.__register__(index, options.weight, options.expiration).then(({success, wait, reservoir}) => {\n\t          var empty;\n\t          this.Events.trigger(\"debug\", `Drained ${options.id}`, {success, args, options});\n\t          if (success) {\n\t            queue.shift();\n\t            empty = this.empty();\n\t            if (empty) {\n\t              this.Events.trigger(\"empty\");\n\t            }\n\t            if (reservoir === 0) {\n\t              this.Events.trigger(\"depleted\", empty);\n\t            }\n\t            this._run(index, next, wait);\n\t            return this.Promise.resolve(options.weight);\n\t          } else {\n\t            return this.Promise.resolve(null);\n\t          }\n\t        });\n\t      });\n\t    }\n\n\t    _drainAll(capacity, total = 0) {\n\t      return this._drainOne(capacity).then((drained) => {\n\t        var newCapacity;\n\t        if (drained != null) {\n\t          newCapacity = capacity != null ? capacity - drained : capacity;\n\t          return this._drainAll(newCapacity, total + drained);\n\t        } else {\n\t          return this.Promise.resolve(total);\n\t        }\n\t      }).catch((e) => {\n\t        return this.Events.trigger(\"error\", e);\n\t      });\n\t    }\n\n\t    _dropAllQueued(message) {\n\t      return this._queues.shiftAll(function(job) {\n\t        return job.doDrop({message});\n\t      });\n\t    }\n\n\t    stop(options = {}) {\n\t      var done, waitForExecuting;\n\t      options = parser$5.load(options, this.stopDefaults);\n\t      waitForExecuting = (at) => {\n\t        var finished;\n\t        finished = () => {\n\t          var counts;\n\t          counts = this._states.counts;\n\t          return (counts[0] + counts[1] + counts[2] + counts[3]) === at;\n\t        };\n\t        return new this.Promise((resolve, reject) => {\n\t          if (finished()) {\n\t            return resolve();\n\t          } else {\n\t            return this.on(\"done\", () => {\n\t              if (finished()) {\n\t                this.removeAllListeners(\"done\");\n\t                return resolve();\n\t              }\n\t            });\n\t          }\n\t        });\n\t      };\n\t      done = options.dropWaitingJobs ? (this._run = function(index, next) {\n\t        return next.doDrop({\n\t          message: options.dropErrorMessage\n\t        });\n\t      }, this._drainOne = () => {\n\t        return this.Promise.resolve(null);\n\t      }, this._registerLock.schedule(() => {\n\t        return this._submitLock.schedule(() => {\n\t          var k, ref, v;\n\t          ref = this._scheduled;\n\t          for (k in ref) {\n\t            v = ref[k];\n\t            if (this.jobStatus(v.job.options.id) === \"RUNNING\") {\n\t              clearTimeout(v.timeout);\n\t              clearTimeout(v.expiration);\n\t              v.job.doDrop({\n\t                message: options.dropErrorMessage\n\t              });\n\t            }\n\t          }\n\t          this._dropAllQueued(options.dropErrorMessage);\n\t          return waitForExecuting(0);\n\t        });\n\t      })) : this.schedule({\n\t        priority: NUM_PRIORITIES$1 - 1,\n\t        weight: 0\n\t      }, () => {\n\t        return waitForExecuting(1);\n\t      });\n\t      this._receive = function(job) {\n\t        return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));\n\t      };\n\t      this.stop = () => {\n\t        return this.Promise.reject(new Bottleneck.prototype.BottleneckError(\"stop() has already been called\"));\n\t      };\n\t      return done;\n\t    }\n\n\t    async _addToQueue(job) {\n\t      var args, blocked, error, options, reachedHWM, shifted, strategy;\n\t      ({args, options} = job);\n\t      try {\n\t        ({reachedHWM, blocked, strategy} = (await this._store.__submit__(this.queued(), options.weight)));\n\t      } catch (error1) {\n\t        error = error1;\n\t        this.Events.trigger(\"debug\", `Could not queue ${options.id}`, {args, options, error});\n\t        job.doDrop({error});\n\t        return false;\n\t      }\n\t      if (blocked) {\n\t        job.doDrop();\n\t        return true;\n\t      } else if (reachedHWM) {\n\t        shifted = strategy === Bottleneck.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;\n\t        if (shifted != null) {\n\t          shifted.doDrop();\n\t        }\n\t        if ((shifted == null) || strategy === Bottleneck.prototype.strategy.OVERFLOW) {\n\t          if (shifted == null) {\n\t            job.doDrop();\n\t          }\n\t          return reachedHWM;\n\t        }\n\t      }\n\t      job.doQueue(reachedHWM, blocked);\n\t      this._queues.push(job);\n\t      await this._drainAll();\n\t      return reachedHWM;\n\t    }\n\n\t    _receive(job) {\n\t      if (this._states.jobStatus(job.options.id) != null) {\n\t        job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));\n\t        return false;\n\t      } else {\n\t        job.doReceive();\n\t        return this._submitLock.schedule(this._addToQueue, job);\n\t      }\n\t    }\n\n\t    submit(...args) {\n\t      var cb, fn, job, options, ref, ref1, task;\n\t      if (typeof args[0] === \"function\") {\n\t        ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);\n\t        options = parser$5.load({}, this.jobDefaults);\n\t      } else {\n\t        ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);\n\t        options = parser$5.load(options, this.jobDefaults);\n\t      }\n\t      task = (...args) => {\n\t        return new this.Promise(function(resolve, reject) {\n\t          return fn(...args, function(...args) {\n\t            return (args[0] != null ? reject : resolve)(args);\n\t          });\n\t        });\n\t      };\n\t      job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n\t      job.promise.then(function(args) {\n\t        return typeof cb === \"function\" ? cb(...args) : void 0;\n\t      }).catch(function(args) {\n\t        if (Array.isArray(args)) {\n\t          return typeof cb === \"function\" ? cb(...args) : void 0;\n\t        } else {\n\t          return typeof cb === \"function\" ? cb(args) : void 0;\n\t        }\n\t      });\n\t      return this._receive(job);\n\t    }\n\n\t    schedule(...args) {\n\t      var job, options, task;\n\t      if (typeof args[0] === \"function\") {\n\t        [task, ...args] = args;\n\t        options = {};\n\t      } else {\n\t        [options, task, ...args] = args;\n\t      }\n\t      job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n\t      this._receive(job);\n\t      return job.promise;\n\t    }\n\n\t    wrap(fn) {\n\t      var schedule, wrapped;\n\t      schedule = this.schedule.bind(this);\n\t      wrapped = function(...args) {\n\t        return schedule(fn.bind(this), ...args);\n\t      };\n\t      wrapped.withOptions = function(options, ...args) {\n\t        return schedule(options, fn, ...args);\n\t      };\n\t      return wrapped;\n\t    }\n\n\t    async updateSettings(options = {}) {\n\t      await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));\n\t      parser$5.overwrite(options, this.instanceDefaults, this);\n\t      return this;\n\t    }\n\n\t    currentReservoir() {\n\t      return this._store.__currentReservoir__();\n\t    }\n\n\t    incrementReservoir(incr = 0) {\n\t      return this._store.__incrementReservoir__(incr);\n\t    }\n\n\t  }\n\t  Bottleneck.default = Bottleneck;\n\n\t  Bottleneck.Events = Events$4;\n\n\t  Bottleneck.version = Bottleneck.prototype.version = require$$8.version;\n\n\t  Bottleneck.strategy = Bottleneck.prototype.strategy = {\n\t    LEAK: 1,\n\t    OVERFLOW: 2,\n\t    OVERFLOW_PRIORITY: 4,\n\t    BLOCK: 3\n\t  };\n\n\t  Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = BottleneckError_1;\n\n\t  Bottleneck.Group = Bottleneck.prototype.Group = Group_1;\n\n\t  Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require$$2;\n\n\t  Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require$$3;\n\n\t  Bottleneck.Batcher = Bottleneck.prototype.Batcher = Batcher_1;\n\n\t  Bottleneck.prototype.jobDefaults = {\n\t    priority: DEFAULT_PRIORITY$1,\n\t    weight: 1,\n\t    expiration: null,\n\t    id: \"<no-id>\"\n\t  };\n\n\t  Bottleneck.prototype.storeDefaults = {\n\t    maxConcurrent: null,\n\t    minTime: 0,\n\t    highWater: null,\n\t    strategy: Bottleneck.prototype.strategy.LEAK,\n\t    penalty: null,\n\t    reservoir: null,\n\t    reservoirRefreshInterval: null,\n\t    reservoirRefreshAmount: null,\n\t    reservoirIncreaseInterval: null,\n\t    reservoirIncreaseAmount: null,\n\t    reservoirIncreaseMaximum: null\n\t  };\n\n\t  Bottleneck.prototype.localStoreDefaults = {\n\t    Promise: Promise,\n\t    timeout: null,\n\t    heartbeatInterval: 250\n\t  };\n\n\t  Bottleneck.prototype.redisStoreDefaults = {\n\t    Promise: Promise,\n\t    timeout: null,\n\t    heartbeatInterval: 5000,\n\t    clientTimeout: 10000,\n\t    Redis: null,\n\t    clientOptions: {},\n\t    clusterNodes: null,\n\t    clearDatastore: false,\n\t    connection: null\n\t  };\n\n\t  Bottleneck.prototype.instanceDefaults = {\n\t    datastore: \"local\",\n\t    connection: null,\n\t    id: \"<no-id>\",\n\t    rejectOnDrop: true,\n\t    trackDoneStatus: false,\n\t    Promise: Promise\n\t  };\n\n\t  Bottleneck.prototype.stopDefaults = {\n\t    enqueueErrorMessage: \"This limiter has been stopped and cannot accept new jobs.\",\n\t    dropWaitingJobs: true,\n\t    dropErrorMessage: \"This limiter has been stopped.\"\n\t  };\n\n\t  return Bottleneck;\n\n\t}).call(commonjsGlobal);\n\n\tvar Bottleneck_1 = Bottleneck;\n\n\tvar lib = Bottleneck_1;\n\n\treturn lib;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm90dGxlbmVjay9saWdodC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLENBQytCO0FBQ2hDLENBQUMsc0JBQXNCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFB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Q0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTywwQkFBMEI7QUFDakM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixRQUFRLGlEQUFpRCxnQ0FBZ0M7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LElBQUkscUJBQXFCO0FBQzdGLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJHQUEyRyxlQUFlO0FBQzFIO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib3R0bGVuZWNrL2xpZ2h0LmpzP2I1NWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBCb3R0bGVuZWNrIGxpYnJhcnkgKE1JVCksIGNvbXBpbGVkIHRvIEVTMjAxNywgYW5kIHdpdGhvdXQgQ2x1c3RlcmluZyBzdXBwb3J0LlxuICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TR3JvbmRpbi9ib3R0bGVuZWNrXG4gICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuQm90dGxlbmVjayA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIChuKSB7XG5cdFx0cmV0dXJuIG4gJiYgblsnZGVmYXVsdCddIHx8IG47XG5cdH1cblxuXHR2YXIgbG9hZCA9IGZ1bmN0aW9uKHJlY2VpdmVkLCBkZWZhdWx0cywgb250byA9IHt9KSB7XG5cdCAgdmFyIGssIHJlZiwgdjtcblx0ICBmb3IgKGsgaW4gZGVmYXVsdHMpIHtcblx0ICAgIHYgPSBkZWZhdWx0c1trXTtcblx0ICAgIG9udG9ba10gPSAocmVmID0gcmVjZWl2ZWRba10pICE9IG51bGwgPyByZWYgOiB2O1xuXHQgIH1cblx0ICByZXR1cm4gb250bztcblx0fTtcblxuXHR2YXIgb3ZlcndyaXRlID0gZnVuY3Rpb24ocmVjZWl2ZWQsIGRlZmF1bHRzLCBvbnRvID0ge30pIHtcblx0ICB2YXIgaywgdjtcblx0ICBmb3IgKGsgaW4gcmVjZWl2ZWQpIHtcblx0ICAgIHYgPSByZWNlaXZlZFtrXTtcblx0ICAgIGlmIChkZWZhdWx0c1trXSAhPT0gdm9pZCAwKSB7XG5cdCAgICAgIG9udG9ba10gPSB2O1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gb250bztcblx0fTtcblxuXHR2YXIgcGFyc2VyID0ge1xuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0b3ZlcndyaXRlOiBvdmVyd3JpdGVcblx0fTtcblxuXHR2YXIgRExMaXN0O1xuXG5cdERMTGlzdCA9IGNsYXNzIERMTGlzdCB7XG5cdCAgY29uc3RydWN0b3IoaW5jciwgZGVjcikge1xuXHQgICAgdGhpcy5pbmNyID0gaW5jcjtcblx0ICAgIHRoaXMuZGVjciA9IGRlY3I7XG5cdCAgICB0aGlzLl9maXJzdCA9IG51bGw7XG5cdCAgICB0aGlzLl9sYXN0ID0gbnVsbDtcblx0ICAgIHRoaXMubGVuZ3RoID0gMDtcblx0ICB9XG5cblx0ICBwdXNoKHZhbHVlKSB7XG5cdCAgICB2YXIgbm9kZTtcblx0ICAgIHRoaXMubGVuZ3RoKys7XG5cdCAgICBpZiAodHlwZW9mIHRoaXMuaW5jciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgIHRoaXMuaW5jcigpO1xuXHQgICAgfVxuXHQgICAgbm9kZSA9IHtcblx0ICAgICAgdmFsdWUsXG5cdCAgICAgIHByZXY6IHRoaXMuX2xhc3QsXG5cdCAgICAgIG5leHQ6IG51bGxcblx0ICAgIH07XG5cdCAgICBpZiAodGhpcy5fbGFzdCAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX2xhc3QubmV4dCA9IG5vZGU7XG5cdCAgICAgIHRoaXMuX2xhc3QgPSBub2RlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fZmlyc3QgPSB0aGlzLl9sYXN0ID0gbm9kZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2b2lkIDA7XG5cdCAgfVxuXG5cdCAgc2hpZnQoKSB7XG5cdCAgICB2YXIgdmFsdWU7XG5cdCAgICBpZiAodGhpcy5fZmlyc3QgPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmxlbmd0aC0tO1xuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuZGVjciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgdGhpcy5kZWNyKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhbHVlID0gdGhpcy5fZmlyc3QudmFsdWU7XG5cdCAgICBpZiAoKHRoaXMuX2ZpcnN0ID0gdGhpcy5fZmlyc3QubmV4dCkgIT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9maXJzdC5wcmV2ID0gbnVsbDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblxuXHQgIGZpcnN0KCkge1xuXHQgICAgaWYgKHRoaXMuX2ZpcnN0ICE9IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0LnZhbHVlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGdldEFycmF5KCkge1xuXHQgICAgdmFyIG5vZGUsIHJlZiwgcmVzdWx0cztcblx0ICAgIG5vZGUgPSB0aGlzLl9maXJzdDtcblx0ICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcblx0ICAgICAgcmVzdWx0cy5wdXNoKChyZWYgPSBub2RlLCBub2RlID0gbm9kZS5uZXh0LCByZWYudmFsdWUpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH1cblxuXHQgIGZvckVhY2hTaGlmdChjYikge1xuXHQgICAgdmFyIG5vZGU7XG5cdCAgICBub2RlID0gdGhpcy5zaGlmdCgpO1xuXHQgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuXHQgICAgICAoY2Iobm9kZSksIG5vZGUgPSB0aGlzLnNoaWZ0KCkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZvaWQgMDtcblx0ICB9XG5cblx0ICBkZWJ1ZygpIHtcblx0ICAgIHZhciBub2RlLCByZWYsIHJlZjEsIHJlZjIsIHJlc3VsdHM7XG5cdCAgICBub2RlID0gdGhpcy5fZmlyc3Q7XG5cdCAgICByZXN1bHRzID0gW107XG5cdCAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG5cdCAgICAgIHJlc3VsdHMucHVzaCgocmVmID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCwge1xuXHQgICAgICAgIHZhbHVlOiByZWYudmFsdWUsXG5cdCAgICAgICAgcHJldjogKHJlZjEgPSByZWYucHJldikgIT0gbnVsbCA/IHJlZjEudmFsdWUgOiB2b2lkIDAsXG5cdCAgICAgICAgbmV4dDogKHJlZjIgPSByZWYubmV4dCkgIT0gbnVsbCA/IHJlZjIudmFsdWUgOiB2b2lkIDBcblx0ICAgICAgfSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfVxuXG5cdH07XG5cblx0dmFyIERMTGlzdF8xID0gRExMaXN0O1xuXG5cdHZhciBFdmVudHM7XG5cblx0RXZlbnRzID0gY2xhc3MgRXZlbnRzIHtcblx0ICBjb25zdHJ1Y3RvcihpbnN0YW5jZSkge1xuXHQgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuXHQgICAgdGhpcy5fZXZlbnRzID0ge307XG5cdCAgICBpZiAoKHRoaXMuaW5zdGFuY2Uub24gIT0gbnVsbCkgfHwgKHRoaXMuaW5zdGFuY2Uub25jZSAhPSBudWxsKSB8fCAodGhpcy5pbnN0YW5jZS5yZW1vdmVBbGxMaXN0ZW5lcnMgIT0gbnVsbCkpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gRW1pdHRlciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBvYmplY3RcIik7XG5cdCAgICB9XG5cdCAgICB0aGlzLmluc3RhbmNlLm9uID0gKG5hbWUsIGNiKSA9PiB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihuYW1lLCBcIm1hbnlcIiwgY2IpO1xuXHQgICAgfTtcblx0ICAgIHRoaXMuaW5zdGFuY2Uub25jZSA9IChuYW1lLCBjYikgPT4ge1xuXHQgICAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmFtZSwgXCJvbmNlXCIsIGNiKTtcblx0ICAgIH07XG5cdCAgICB0aGlzLmluc3RhbmNlLnJlbW92ZUFsbExpc3RlbmVycyA9IChuYW1lID0gbnVsbCkgPT4ge1xuXHQgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cyA9IHt9O1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIF9hZGRMaXN0ZW5lcihuYW1lLCBzdGF0dXMsIGNiKSB7XG5cdCAgICB2YXIgYmFzZTtcblx0ICAgIGlmICgoYmFzZSA9IHRoaXMuX2V2ZW50cylbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICBiYXNlW25hbWVdID0gW107XG5cdCAgICB9XG5cdCAgICB0aGlzLl9ldmVudHNbbmFtZV0ucHVzaCh7Y2IsIHN0YXR1c30pO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG5cdCAgfVxuXG5cdCAgbGlzdGVuZXJDb3VudChuYW1lKSB7XG5cdCAgICBpZiAodGhpcy5fZXZlbnRzW25hbWVdICE9IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1tuYW1lXS5sZW5ndGg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBhc3luYyB0cmlnZ2VyKG5hbWUsIC4uLmFyZ3MpIHtcblx0ICAgIHZhciBlLCBwcm9taXNlcztcblx0ICAgIHRyeSB7XG5cdCAgICAgIGlmIChuYW1lICE9PSBcImRlYnVnXCIpIHtcblx0ICAgICAgICB0aGlzLnRyaWdnZXIoXCJkZWJ1Z1wiLCBgRXZlbnQgdHJpZ2dlcmVkOiAke25hbWV9YCwgYXJncyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuX2V2ZW50c1tuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IHRoaXMuX2V2ZW50c1tuYW1lXS5maWx0ZXIoZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0ICAgICAgICByZXR1cm4gbGlzdGVuZXIuc3RhdHVzICE9PSBcIm5vbmVcIjtcblx0ICAgICAgfSk7XG5cdCAgICAgIHByb21pc2VzID0gdGhpcy5fZXZlbnRzW25hbWVdLm1hcChhc3luYyhsaXN0ZW5lcikgPT4ge1xuXHQgICAgICAgIHZhciBlLCByZXR1cm5lZDtcblx0ICAgICAgICBpZiAobGlzdGVuZXIuc3RhdHVzID09PSBcIm5vbmVcIikge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobGlzdGVuZXIuc3RhdHVzID09PSBcIm9uY2VcIikge1xuXHQgICAgICAgICAgbGlzdGVuZXIuc3RhdHVzID0gXCJub25lXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICByZXR1cm5lZCA9IHR5cGVvZiBsaXN0ZW5lci5jYiA9PT0gXCJmdW5jdGlvblwiID8gbGlzdGVuZXIuY2IoLi4uYXJncykgOiB2b2lkIDA7XG5cdCAgICAgICAgICBpZiAodHlwZW9mIChyZXR1cm5lZCAhPSBudWxsID8gcmV0dXJuZWQudGhlbiA6IHZvaWQgMCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGF3YWl0IHJldHVybmVkKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiByZXR1cm5lZDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgZSA9IGVycm9yO1xuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJlcnJvclwiLCBlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiAoKGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKSkpLmZpbmQoZnVuY3Rpb24oeCkge1xuXHQgICAgICAgIHJldHVybiB4ICE9IG51bGw7XG5cdCAgICAgIH0pO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgZSA9IGVycm9yO1xuXHQgICAgICB7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyKFwiZXJyb3JcIiwgZSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgfVxuXG5cdH07XG5cblx0dmFyIEV2ZW50c18xID0gRXZlbnRzO1xuXG5cdHZhciBETExpc3QkMSwgRXZlbnRzJDEsIFF1ZXVlcztcblxuXHRETExpc3QkMSA9IERMTGlzdF8xO1xuXG5cdEV2ZW50cyQxID0gRXZlbnRzXzE7XG5cblx0UXVldWVzID0gY2xhc3MgUXVldWVzIHtcblx0ICBjb25zdHJ1Y3RvcihudW1fcHJpb3JpdGllcykge1xuXHQgICAgdmFyIGk7XG5cdCAgICB0aGlzLkV2ZW50cyA9IG5ldyBFdmVudHMkMSh0aGlzKTtcblx0ICAgIHRoaXMuX2xlbmd0aCA9IDA7XG5cdCAgICB0aGlzLl9saXN0cyA9IChmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGosIHJlZiwgcmVzdWx0cztcblx0ICAgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgICBmb3IgKGkgPSBqID0gMSwgcmVmID0gbnVtX3ByaW9yaXRpZXM7ICgxIDw9IHJlZiA/IGogPD0gcmVmIDogaiA+PSByZWYpOyBpID0gMSA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgICByZXN1bHRzLnB1c2gobmV3IERMTGlzdCQxKCgoKSA9PiB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5pbmNyKCk7XG5cdCAgICAgICAgfSksICgoKSA9PiB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyKCk7XG5cdCAgICAgICAgfSkpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgIH0pLmNhbGwodGhpcyk7XG5cdCAgfVxuXG5cdCAgaW5jcigpIHtcblx0ICAgIGlmICh0aGlzLl9sZW5ndGgrKyA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5FdmVudHMudHJpZ2dlcihcImxlZnR6ZXJvXCIpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGRlY3IoKSB7XG5cdCAgICBpZiAoLS10aGlzLl9sZW5ndGggPT09IDApIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuRXZlbnRzLnRyaWdnZXIoXCJ6ZXJvXCIpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHB1c2goam9iKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fbGlzdHNbam9iLm9wdGlvbnMucHJpb3JpdHldLnB1c2goam9iKTtcblx0ICB9XG5cblx0ICBxdWV1ZWQocHJpb3JpdHkpIHtcblx0ICAgIGlmIChwcmlvcml0eSAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9saXN0c1twcmlvcml0eV0ubGVuZ3RoO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBzaGlmdEFsbChmbikge1xuXHQgICAgcmV0dXJuIHRoaXMuX2xpc3RzLmZvckVhY2goZnVuY3Rpb24obGlzdCkge1xuXHQgICAgICByZXR1cm4gbGlzdC5mb3JFYWNoU2hpZnQoZm4pO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZ2V0Rmlyc3QoYXJyID0gdGhpcy5fbGlzdHMpIHtcblx0ICAgIHZhciBqLCBsZW4sIGxpc3Q7XG5cdCAgICBmb3IgKGogPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcblx0ICAgICAgbGlzdCA9IGFycltqXTtcblx0ICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIHJldHVybiBsaXN0O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gW107XG5cdCAgfVxuXG5cdCAgc2hpZnRMYXN0RnJvbShwcmlvcml0eSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3QodGhpcy5fbGlzdHMuc2xpY2UocHJpb3JpdHkpLnJldmVyc2UoKSkuc2hpZnQoKTtcblx0ICB9XG5cblx0fTtcblxuXHR2YXIgUXVldWVzXzEgPSBRdWV1ZXM7XG5cblx0dmFyIEJvdHRsZW5lY2tFcnJvcjtcblxuXHRCb3R0bGVuZWNrRXJyb3IgPSBjbGFzcyBCb3R0bGVuZWNrRXJyb3IgZXh0ZW5kcyBFcnJvciB7fTtcblxuXHR2YXIgQm90dGxlbmVja0Vycm9yXzEgPSBCb3R0bGVuZWNrRXJyb3I7XG5cblx0dmFyIEJvdHRsZW5lY2tFcnJvciQxLCBERUZBVUxUX1BSSU9SSVRZLCBKb2IsIE5VTV9QUklPUklUSUVTLCBwYXJzZXIkMTtcblxuXHROVU1fUFJJT1JJVElFUyA9IDEwO1xuXG5cdERFRkFVTFRfUFJJT1JJVFkgPSA1O1xuXG5cdHBhcnNlciQxID0gcGFyc2VyO1xuXG5cdEJvdHRsZW5lY2tFcnJvciQxID0gQm90dGxlbmVja0Vycm9yXzE7XG5cblx0Sm9iID0gY2xhc3MgSm9iIHtcblx0ICBjb25zdHJ1Y3Rvcih0YXNrLCBhcmdzLCBvcHRpb25zLCBqb2JEZWZhdWx0cywgcmVqZWN0T25Ecm9wLCBFdmVudHMsIF9zdGF0ZXMsIFByb21pc2UpIHtcblx0ICAgIHRoaXMudGFzayA9IHRhc2s7XG5cdCAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuXHQgICAgdGhpcy5yZWplY3RPbkRyb3AgPSByZWplY3RPbkRyb3A7XG5cdCAgICB0aGlzLkV2ZW50cyA9IEV2ZW50cztcblx0ICAgIHRoaXMuX3N0YXRlcyA9IF9zdGF0ZXM7XG5cdCAgICB0aGlzLlByb21pc2UgPSBQcm9taXNlO1xuXHQgICAgdGhpcy5vcHRpb25zID0gcGFyc2VyJDEubG9hZChvcHRpb25zLCBqb2JEZWZhdWx0cyk7XG5cdCAgICB0aGlzLm9wdGlvbnMucHJpb3JpdHkgPSB0aGlzLl9zYW5pdGl6ZVByaW9yaXR5KHRoaXMub3B0aW9ucy5wcmlvcml0eSk7XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmlkID09PSBqb2JEZWZhdWx0cy5pZCkge1xuXHQgICAgICB0aGlzLm9wdGlvbnMuaWQgPSBgJHt0aGlzLm9wdGlvbnMuaWR9LSR7dGhpcy5fcmFuZG9tSW5kZXgoKX1gO1xuXHQgICAgfVxuXHQgICAgdGhpcy5wcm9taXNlID0gbmV3IHRoaXMuUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcblx0ICAgICAgdGhpcy5fcmVzb2x2ZSA9IF9yZXNvbHZlO1xuXHQgICAgICB0aGlzLl9yZWplY3QgPSBfcmVqZWN0O1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuXHQgIH1cblxuXHQgIF9zYW5pdGl6ZVByaW9yaXR5KHByaW9yaXR5KSB7XG5cdCAgICB2YXIgc1Byb3BlcnR5O1xuXHQgICAgc1Byb3BlcnR5ID0gfn5wcmlvcml0eSAhPT0gcHJpb3JpdHkgPyBERUZBVUxUX1BSSU9SSVRZIDogcHJpb3JpdHk7XG5cdCAgICBpZiAoc1Byb3BlcnR5IDwgMCkge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH0gZWxzZSBpZiAoc1Byb3BlcnR5ID4gTlVNX1BSSU9SSVRJRVMgLSAxKSB7XG5cdCAgICAgIHJldHVybiBOVU1fUFJJT1JJVElFUyAtIDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gc1Byb3BlcnR5O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIF9yYW5kb21JbmRleCgpIHtcblx0ICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblx0ICB9XG5cblx0ICBkb0Ryb3Aoe2Vycm9yLCBtZXNzYWdlID0gXCJUaGlzIGpvYiBoYXMgYmVlbiBkcm9wcGVkIGJ5IEJvdHRsZW5lY2tcIn0gPSB7fSkge1xuXHQgICAgaWYgKHRoaXMuX3N0YXRlcy5yZW1vdmUodGhpcy5vcHRpb25zLmlkKSkge1xuXHQgICAgICBpZiAodGhpcy5yZWplY3RPbkRyb3ApIHtcblx0ICAgICAgICB0aGlzLl9yZWplY3QoZXJyb3IgIT0gbnVsbCA/IGVycm9yIDogbmV3IEJvdHRsZW5lY2tFcnJvciQxKG1lc3NhZ2UpKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLkV2ZW50cy50cmlnZ2VyKFwiZHJvcHBlZFwiLCB7YXJnczogdGhpcy5hcmdzLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMsIHRhc2s6IHRoaXMudGFzaywgcHJvbWlzZTogdGhpcy5wcm9taXNlfSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIF9hc3NlcnRTdGF0dXMoZXhwZWN0ZWQpIHtcblx0ICAgIHZhciBzdGF0dXM7XG5cdCAgICBzdGF0dXMgPSB0aGlzLl9zdGF0ZXMuam9iU3RhdHVzKHRoaXMub3B0aW9ucy5pZCk7XG5cdCAgICBpZiAoIShzdGF0dXMgPT09IGV4cGVjdGVkIHx8IChleHBlY3RlZCA9PT0gXCJET05FXCIgJiYgc3RhdHVzID09PSBudWxsKSkpIHtcblx0ICAgICAgdGhyb3cgbmV3IEJvdHRsZW5lY2tFcnJvciQxKGBJbnZhbGlkIGpvYiBzdGF0dXMgJHtzdGF0dXN9LCBleHBlY3RlZCAke2V4cGVjdGVkfS4gUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1NHcm9uZGluL2JvdHRsZW5lY2svaXNzdWVzYCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZG9SZWNlaXZlKCkge1xuXHQgICAgdGhpcy5fc3RhdGVzLnN0YXJ0KHRoaXMub3B0aW9ucy5pZCk7XG5cdCAgICByZXR1cm4gdGhpcy5FdmVudHMudHJpZ2dlcihcInJlY2VpdmVkXCIsIHthcmdzOiB0aGlzLmFyZ3MsIG9wdGlvbnM6IHRoaXMub3B0aW9uc30pO1xuXHQgIH1cblxuXHQgIGRvUXVldWUocmVhY2hlZEhXTSwgYmxvY2tlZCkge1xuXHQgICAgdGhpcy5fYXNzZXJ0U3RhdHVzKFwiUkVDRUlWRURcIik7XG5cdCAgICB0aGlzLl9zdGF0ZXMubmV4dCh0aGlzLm9wdGlvbnMuaWQpO1xuXHQgICAgcmV0dXJuIHRoaXMuRXZlbnRzLnRyaWdnZXIoXCJxdWV1ZWRcIiwge2FyZ3M6IHRoaXMuYXJncywgb3B0aW9uczogdGhpcy5vcHRpb25zLCByZWFjaGVkSFdNLCBibG9ja2VkfSk7XG5cdCAgfVxuXG5cdCAgZG9SdW4oKSB7XG5cdCAgICBpZiAodGhpcy5yZXRyeUNvdW50ID09PSAwKSB7XG5cdCAgICAgIHRoaXMuX2Fzc2VydFN0YXR1cyhcIlFVRVVFRFwiKTtcblx0ICAgICAgdGhpcy5fc3RhdGVzLm5leHQodGhpcy5vcHRpb25zLmlkKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX2Fzc2VydFN0YXR1cyhcIkVYRUNVVElOR1wiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLkV2ZW50cy50cmlnZ2VyKFwic2NoZWR1bGVkXCIsIHthcmdzOiB0aGlzLmFyZ3MsIG9wdGlvbnM6IHRoaXMub3B0aW9uc30pO1xuXHQgIH1cblxuXHQgIGFzeW5jIGRvRXhlY3V0ZShjaGFpbmVkLCBjbGVhckdsb2JhbFN0YXRlLCBydW4sIGZyZWUpIHtcblx0ICAgIHZhciBlcnJvciwgZXZlbnRJbmZvLCBwYXNzZWQ7XG5cdCAgICBpZiAodGhpcy5yZXRyeUNvdW50ID09PSAwKSB7XG5cdCAgICAgIHRoaXMuX2Fzc2VydFN0YXR1cyhcIlJVTk5JTkdcIik7XG5cdCAgICAgIHRoaXMuX3N0YXRlcy5uZXh0KHRoaXMub3B0aW9ucy5pZCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9hc3NlcnRTdGF0dXMoXCJFWEVDVVRJTkdcIik7XG5cdCAgICB9XG5cdCAgICBldmVudEluZm8gPSB7YXJnczogdGhpcy5hcmdzLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMsIHJldHJ5Q291bnQ6IHRoaXMucmV0cnlDb3VudH07XG5cdCAgICB0aGlzLkV2ZW50cy50cmlnZ2VyKFwiZXhlY3V0aW5nXCIsIGV2ZW50SW5mbyk7XG5cdCAgICB0cnkge1xuXHQgICAgICBwYXNzZWQgPSAoYXdhaXQgKGNoYWluZWQgIT0gbnVsbCA/IGNoYWluZWQuc2NoZWR1bGUodGhpcy5vcHRpb25zLCB0aGlzLnRhc2ssIC4uLnRoaXMuYXJncykgOiB0aGlzLnRhc2soLi4udGhpcy5hcmdzKSkpO1xuXHQgICAgICBpZiAoY2xlYXJHbG9iYWxTdGF0ZSgpKSB7XG5cdCAgICAgICAgdGhpcy5kb0RvbmUoZXZlbnRJbmZvKTtcblx0ICAgICAgICBhd2FpdCBmcmVlKHRoaXMub3B0aW9ucywgZXZlbnRJbmZvKTtcblx0ICAgICAgICB0aGlzLl9hc3NlcnRTdGF0dXMoXCJET05FXCIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHBhc3NlZCk7XG5cdCAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuXHQgICAgICBlcnJvciA9IGVycm9yMTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX29uRmFpbHVyZShlcnJvciwgZXZlbnRJbmZvLCBjbGVhckdsb2JhbFN0YXRlLCBydW4sIGZyZWUpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGRvRXhwaXJlKGNsZWFyR2xvYmFsU3RhdGUsIHJ1biwgZnJlZSkge1xuXHQgICAgdmFyIGVycm9yLCBldmVudEluZm87XG5cdCAgICBpZiAodGhpcy5fc3RhdGVzLmpvYlN0YXR1cyh0aGlzLm9wdGlvbnMuaWQgPT09IFwiUlVOTklOR1wiKSkge1xuXHQgICAgICB0aGlzLl9zdGF0ZXMubmV4dCh0aGlzLm9wdGlvbnMuaWQpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fYXNzZXJ0U3RhdHVzKFwiRVhFQ1VUSU5HXCIpO1xuXHQgICAgZXZlbnRJbmZvID0ge2FyZ3M6IHRoaXMuYXJncywgb3B0aW9uczogdGhpcy5vcHRpb25zLCByZXRyeUNvdW50OiB0aGlzLnJldHJ5Q291bnR9O1xuXHQgICAgZXJyb3IgPSBuZXcgQm90dGxlbmVja0Vycm9yJDEoYFRoaXMgam9iIHRpbWVkIG91dCBhZnRlciAke3RoaXMub3B0aW9ucy5leHBpcmF0aW9ufSBtcy5gKTtcblx0ICAgIHJldHVybiB0aGlzLl9vbkZhaWx1cmUoZXJyb3IsIGV2ZW50SW5mbywgY2xlYXJHbG9iYWxTdGF0ZSwgcnVuLCBmcmVlKTtcblx0ICB9XG5cblx0ICBhc3luYyBfb25GYWlsdXJlKGVycm9yLCBldmVudEluZm8sIGNsZWFyR2xvYmFsU3RhdGUsIHJ1biwgZnJlZSkge1xuXHQgICAgdmFyIHJldHJ5LCByZXRyeUFmdGVyO1xuXHQgICAgaWYgKGNsZWFyR2xvYmFsU3RhdGUoKSkge1xuXHQgICAgICByZXRyeSA9IChhd2FpdCB0aGlzLkV2ZW50cy50cmlnZ2VyKFwiZmFpbGVkXCIsIGVycm9yLCBldmVudEluZm8pKTtcblx0ICAgICAgaWYgKHJldHJ5ICE9IG51bGwpIHtcblx0ICAgICAgICByZXRyeUFmdGVyID0gfn5yZXRyeTtcblx0ICAgICAgICB0aGlzLkV2ZW50cy50cmlnZ2VyKFwicmV0cnlcIiwgYFJldHJ5aW5nICR7dGhpcy5vcHRpb25zLmlkfSBhZnRlciAke3JldHJ5QWZ0ZXJ9IG1zYCwgZXZlbnRJbmZvKTtcblx0ICAgICAgICB0aGlzLnJldHJ5Q291bnQrKztcblx0ICAgICAgICByZXR1cm4gcnVuKHJldHJ5QWZ0ZXIpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuZG9Eb25lKGV2ZW50SW5mbyk7XG5cdCAgICAgICAgYXdhaXQgZnJlZSh0aGlzLm9wdGlvbnMsIGV2ZW50SW5mbyk7XG5cdCAgICAgICAgdGhpcy5fYXNzZXJ0U3RhdHVzKFwiRE9ORVwiKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KGVycm9yKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIGRvRG9uZShldmVudEluZm8pIHtcblx0ICAgIHRoaXMuX2Fzc2VydFN0YXR1cyhcIkVYRUNVVElOR1wiKTtcblx0ICAgIHRoaXMuX3N0YXRlcy5uZXh0KHRoaXMub3B0aW9ucy5pZCk7XG5cdCAgICByZXR1cm4gdGhpcy5FdmVudHMudHJpZ2dlcihcImRvbmVcIiwgZXZlbnRJbmZvKTtcblx0ICB9XG5cblx0fTtcblxuXHR2YXIgSm9iXzEgPSBKb2I7XG5cblx0dmFyIEJvdHRsZW5lY2tFcnJvciQyLCBMb2NhbERhdGFzdG9yZSwgcGFyc2VyJDI7XG5cblx0cGFyc2VyJDIgPSBwYXJzZXI7XG5cblx0Qm90dGxlbmVja0Vycm9yJDIgPSBCb3R0bGVuZWNrRXJyb3JfMTtcblxuXHRMb2NhbERhdGFzdG9yZSA9IGNsYXNzIExvY2FsRGF0YXN0b3JlIHtcblx0ICBjb25zdHJ1Y3RvcihpbnN0YW5jZSwgc3RvcmVPcHRpb25zLCBzdG9yZUluc3RhbmNlT3B0aW9ucykge1xuXHQgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuXHQgICAgdGhpcy5zdG9yZU9wdGlvbnMgPSBzdG9yZU9wdGlvbnM7XG5cdCAgICB0aGlzLmNsaWVudElkID0gdGhpcy5pbnN0YW5jZS5fcmFuZG9tSW5kZXgoKTtcblx0ICAgIHBhcnNlciQyLmxvYWQoc3RvcmVJbnN0YW5jZU9wdGlvbnMsIHN0b3JlSW5zdGFuY2VPcHRpb25zLCB0aGlzKTtcblx0ICAgIHRoaXMuX25leHRSZXF1ZXN0ID0gdGhpcy5fbGFzdFJlc2Vydm9pclJlZnJlc2ggPSB0aGlzLl9sYXN0UmVzZXJ2b2lySW5jcmVhc2UgPSBEYXRlLm5vdygpO1xuXHQgICAgdGhpcy5fcnVubmluZyA9IDA7XG5cdCAgICB0aGlzLl9kb25lID0gMDtcblx0ICAgIHRoaXMuX3VuYmxvY2tUaW1lID0gMDtcblx0ICAgIHRoaXMucmVhZHkgPSB0aGlzLlByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgdGhpcy5jbGllbnRzID0ge307XG5cdCAgICB0aGlzLl9zdGFydEhlYXJ0YmVhdCgpO1xuXHQgIH1cblxuXHQgIF9zdGFydEhlYXJ0YmVhdCgpIHtcblx0ICAgIHZhciBiYXNlO1xuXHQgICAgaWYgKCh0aGlzLmhlYXJ0YmVhdCA9PSBudWxsKSAmJiAoKCh0aGlzLnN0b3JlT3B0aW9ucy5yZXNlcnZvaXJSZWZyZXNoSW50ZXJ2YWwgIT0gbnVsbCkgJiYgKHRoaXMuc3RvcmVPcHRpb25zLnJlc2Vydm9pclJlZnJlc2hBbW91bnQgIT0gbnVsbCkpIHx8ICgodGhpcy5zdG9yZU9wdGlvbnMucmVzZXJ2b2lySW5jcmVhc2VJbnRlcnZhbCAhPSBudWxsKSAmJiAodGhpcy5zdG9yZU9wdGlvbnMucmVzZXJ2b2lySW5jcmVhc2VBbW91bnQgIT0gbnVsbCkpKSkge1xuXHQgICAgICByZXR1cm4gdHlwZW9mIChiYXNlID0gKHRoaXMuaGVhcnRiZWF0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHQgICAgICAgIHZhciBhbW91bnQsIGluY3IsIG1heGltdW0sIG5vdywgcmVzZXJ2b2lyO1xuXHQgICAgICAgIG5vdyA9IERhdGUubm93KCk7XG5cdCAgICAgICAgaWYgKCh0aGlzLnN0b3JlT3B0aW9ucy5yZXNlcnZvaXJSZWZyZXNoSW50ZXJ2YWwgIT0gbnVsbCkgJiYgbm93ID49IHRoaXMuX2xhc3RSZXNlcnZvaXJSZWZyZXNoICsgdGhpcy5zdG9yZU9wdGlvbnMucmVzZXJ2b2lyUmVmcmVzaEludGVydmFsKSB7XG5cdCAgICAgICAgICB0aGlzLl9sYXN0UmVzZXJ2b2lyUmVmcmVzaCA9IG5vdztcblx0ICAgICAgICAgIHRoaXMuc3RvcmVPcHRpb25zLnJlc2Vydm9pciA9IHRoaXMuc3RvcmVPcHRpb25zLnJlc2Vydm9pclJlZnJlc2hBbW91bnQ7XG5cdCAgICAgICAgICB0aGlzLmluc3RhbmNlLl9kcmFpbkFsbCh0aGlzLmNvbXB1dGVDYXBhY2l0eSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCh0aGlzLnN0b3JlT3B0aW9ucy5yZXNlcnZvaXJJbmNyZWFzZUludGVydmFsICE9IG51bGwpICYmIG5vdyA+PSB0aGlzLl9sYXN0UmVzZXJ2b2lySW5jcmVhc2UgKyB0aGlzLnN0b3JlT3B0aW9ucy5yZXNlcnZvaXJJbmNyZWFzZUludGVydmFsKSB7XG5cdCAgICAgICAgICAoe1xuXHQgICAgICAgICAgICByZXNlcnZvaXJJbmNyZWFzZUFtb3VudDogYW1vdW50LFxuXHQgICAgICAgICAgICByZXNlcnZvaXJJbmNyZWFzZU1heGltdW06IG1heGltdW0sXG5cdCAgICAgICAgICAgIHJlc2Vydm9pclxuXHQgICAgICAgICAgfSA9IHRoaXMuc3RvcmVPcHRpb25zKTtcblx0ICAgICAgICAgIHRoaXMuX2xhc3RSZXNlcnZvaXJJbmNyZWFzZSA9IG5vdztcblx0ICAgICAgICAgIGluY3IgPSBtYXhpbXVtICE9IG51bGwgPyBNYXRoLm1pbihhbW91bnQsIG1heGltdW0gLSByZXNlcnZvaXIpIDogYW1vdW50O1xuXHQgICAgICAgICAgaWYgKGluY3IgPiAwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RvcmVPcHRpb25zLnJlc2Vydm9pciArPSBpbmNyO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5fZHJhaW5BbGwodGhpcy5jb21wdXRlQ2FwYWNpdHkoKSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9LCB0aGlzLmhlYXJ0YmVhdEludGVydmFsKSkpLnVucmVmID09PSBcImZ1bmN0aW9uXCIgPyBiYXNlLnVucmVmKCkgOiB2b2lkIDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgYXN5bmMgX19wdWJsaXNoX18obWVzc2FnZSkge1xuXHQgICAgYXdhaXQgdGhpcy55aWVsZExvb3AoKTtcblx0ICAgIHJldHVybiB0aGlzLmluc3RhbmNlLkV2ZW50cy50cmlnZ2VyKFwibWVzc2FnZVwiLCBtZXNzYWdlLnRvU3RyaW5nKCkpO1xuXHQgIH1cblxuXHQgIGFzeW5jIF9fZGlzY29ubmVjdF9fKGZsdXNoKSB7XG5cdCAgICBhd2FpdCB0aGlzLnlpZWxkTG9vcCgpO1xuXHQgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdCk7XG5cdCAgICByZXR1cm4gdGhpcy5Qcm9taXNlLnJlc29sdmUoKTtcblx0ICB9XG5cblx0ICB5aWVsZExvb3AodCA9IDApIHtcblx0ICAgIHJldHVybiBuZXcgdGhpcy5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCB0KTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGNvbXB1dGVQZW5hbHR5KCkge1xuXHQgICAgdmFyIHJlZjtcblx0ICAgIHJldHVybiAocmVmID0gdGhpcy5zdG9yZU9wdGlvbnMucGVuYWx0eSkgIT0gbnVsbCA/IHJlZiA6ICgxNSAqIHRoaXMuc3RvcmVPcHRpb25zLm1pblRpbWUpIHx8IDUwMDA7XG5cdCAgfVxuXG5cdCAgYXN5bmMgX191cGRhdGVTZXR0aW5nc19fKG9wdGlvbnMpIHtcblx0ICAgIGF3YWl0IHRoaXMueWllbGRMb29wKCk7XG5cdCAgICBwYXJzZXIkMi5vdmVyd3JpdGUob3B0aW9ucywgb3B0aW9ucywgdGhpcy5zdG9yZU9wdGlvbnMpO1xuXHQgICAgdGhpcy5fc3RhcnRIZWFydGJlYXQoKTtcblx0ICAgIHRoaXMuaW5zdGFuY2UuX2RyYWluQWxsKHRoaXMuY29tcHV0ZUNhcGFjaXR5KCkpO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgYXN5bmMgX19ydW5uaW5nX18oKSB7XG5cdCAgICBhd2FpdCB0aGlzLnlpZWxkTG9vcCgpO1xuXHQgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XG5cdCAgfVxuXG5cdCAgYXN5bmMgX19xdWV1ZWRfXygpIHtcblx0ICAgIGF3YWl0IHRoaXMueWllbGRMb29wKCk7XG5cdCAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5xdWV1ZWQoKTtcblx0ICB9XG5cblx0ICBhc3luYyBfX2RvbmVfXygpIHtcblx0ICAgIGF3YWl0IHRoaXMueWllbGRMb29wKCk7XG5cdCAgICByZXR1cm4gdGhpcy5fZG9uZTtcblx0ICB9XG5cblx0ICBhc3luYyBfX2dyb3VwQ2hlY2tfXyh0aW1lKSB7XG5cdCAgICBhd2FpdCB0aGlzLnlpZWxkTG9vcCgpO1xuXHQgICAgcmV0dXJuICh0aGlzLl9uZXh0UmVxdWVzdCArIHRoaXMudGltZW91dCkgPCB0aW1lO1xuXHQgIH1cblxuXHQgIGNvbXB1dGVDYXBhY2l0eSgpIHtcblx0ICAgIHZhciBtYXhDb25jdXJyZW50LCByZXNlcnZvaXI7XG5cdCAgICAoe21heENvbmN1cnJlbnQsIHJlc2Vydm9pcn0gPSB0aGlzLnN0b3JlT3B0aW9ucyk7XG5cdCAgICBpZiAoKG1heENvbmN1cnJlbnQgIT0gbnVsbCkgJiYgKHJlc2Vydm9pciAhPSBudWxsKSkge1xuXHQgICAgICByZXR1cm4gTWF0aC5taW4obWF4Q29uY3VycmVudCAtIHRoaXMuX3J1bm5pbmcsIHJlc2Vydm9pcik7XG5cdCAgICB9IGVsc2UgaWYgKG1heENvbmN1cnJlbnQgIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gbWF4Q29uY3VycmVudCAtIHRoaXMuX3J1bm5pbmc7XG5cdCAgICB9IGVsc2UgaWYgKHJlc2Vydm9pciAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiByZXNlcnZvaXI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBjb25kaXRpb25zQ2hlY2sod2VpZ2h0KSB7XG5cdCAgICB2YXIgY2FwYWNpdHk7XG5cdCAgICBjYXBhY2l0eSA9IHRoaXMuY29tcHV0ZUNhcGFjaXR5KCk7XG5cdCAgICByZXR1cm4gKGNhcGFjaXR5ID09IG51bGwpIHx8IHdlaWdodCA8PSBjYXBhY2l0eTtcblx0ICB9XG5cblx0ICBhc3luYyBfX2luY3JlbWVudFJlc2Vydm9pcl9fKGluY3IpIHtcblx0ICAgIHZhciByZXNlcnZvaXI7XG5cdCAgICBhd2FpdCB0aGlzLnlpZWxkTG9vcCgpO1xuXHQgICAgcmVzZXJ2b2lyID0gdGhpcy5zdG9yZU9wdGlvbnMucmVzZXJ2b2lyICs9IGluY3I7XG5cdCAgICB0aGlzLmluc3RhbmNlLl9kcmFpbkFsbCh0aGlzLmNvbXB1dGVDYXBhY2l0eSgpKTtcblx0ICAgIHJldHVybiByZXNlcnZvaXI7XG5cdCAgfVxuXG5cdCAgYXN5bmMgX19jdXJyZW50UmVzZXJ2b2lyX18oKSB7XG5cdCAgICBhd2FpdCB0aGlzLnlpZWxkTG9vcCgpO1xuXHQgICAgcmV0dXJuIHRoaXMuc3RvcmVPcHRpb25zLnJlc2Vydm9pcjtcblx0ICB9XG5cblx0ICBpc0Jsb2NrZWQobm93KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdW5ibG9ja1RpbWUgPj0gbm93O1xuXHQgIH1cblxuXHQgIGNoZWNrKHdlaWdodCwgbm93KSB7XG5cdCAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zQ2hlY2sod2VpZ2h0KSAmJiAodGhpcy5fbmV4dFJlcXVlc3QgLSBub3cpIDw9IDA7XG5cdCAgfVxuXG5cdCAgYXN5bmMgX19jaGVja19fKHdlaWdodCkge1xuXHQgICAgdmFyIG5vdztcblx0ICAgIGF3YWl0IHRoaXMueWllbGRMb29wKCk7XG5cdCAgICBub3cgPSBEYXRlLm5vdygpO1xuXHQgICAgcmV0dXJuIHRoaXMuY2hlY2sod2VpZ2h0LCBub3cpO1xuXHQgIH1cblxuXHQgIGFzeW5jIF9fcmVnaXN0ZXJfXyhpbmRleCwgd2VpZ2h0LCBleHBpcmF0aW9uKSB7XG5cdCAgICB2YXIgbm93LCB3YWl0O1xuXHQgICAgYXdhaXQgdGhpcy55aWVsZExvb3AoKTtcblx0ICAgIG5vdyA9IERhdGUubm93KCk7XG5cdCAgICBpZiAodGhpcy5jb25kaXRpb25zQ2hlY2sod2VpZ2h0KSkge1xuXHQgICAgICB0aGlzLl9ydW5uaW5nICs9IHdlaWdodDtcblx0ICAgICAgaWYgKHRoaXMuc3RvcmVPcHRpb25zLnJlc2Vydm9pciAhPSBudWxsKSB7XG5cdCAgICAgICAgdGhpcy5zdG9yZU9wdGlvbnMucmVzZXJ2b2lyIC09IHdlaWdodDtcblx0ICAgICAgfVxuXHQgICAgICB3YWl0ID0gTWF0aC5tYXgodGhpcy5fbmV4dFJlcXVlc3QgLSBub3csIDApO1xuXHQgICAgICB0aGlzLl9uZXh0UmVxdWVzdCA9IG5vdyArIHdhaXQgKyB0aGlzLnN0b3JlT3B0aW9ucy5taW5UaW1lO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG5cdCAgICAgICAgd2FpdCxcblx0ICAgICAgICByZXNlcnZvaXI6IHRoaXMuc3RvcmVPcHRpb25zLnJlc2Vydm9pclxuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBzdWNjZXNzOiBmYWxzZVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHN0cmF0ZWd5SXNCbG9jaygpIHtcblx0ICAgIHJldHVybiB0aGlzLnN0b3JlT3B0aW9ucy5zdHJhdGVneSA9PT0gMztcblx0ICB9XG5cblx0ICBhc3luYyBfX3N1Ym1pdF9fKHF1ZXVlTGVuZ3RoLCB3ZWlnaHQpIHtcblx0ICAgIHZhciBibG9ja2VkLCBub3csIHJlYWNoZWRIV007XG5cdCAgICBhd2FpdCB0aGlzLnlpZWxkTG9vcCgpO1xuXHQgICAgaWYgKCh0aGlzLnN0b3JlT3B0aW9ucy5tYXhDb25jdXJyZW50ICE9IG51bGwpICYmIHdlaWdodCA+IHRoaXMuc3RvcmVPcHRpb25zLm1heENvbmN1cnJlbnQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEJvdHRsZW5lY2tFcnJvciQyKGBJbXBvc3NpYmxlIHRvIGFkZCBhIGpvYiBoYXZpbmcgYSB3ZWlnaHQgb2YgJHt3ZWlnaHR9IHRvIGEgbGltaXRlciBoYXZpbmcgYSBtYXhDb25jdXJyZW50IHNldHRpbmcgb2YgJHt0aGlzLnN0b3JlT3B0aW9ucy5tYXhDb25jdXJyZW50fWApO1xuXHQgICAgfVxuXHQgICAgbm93ID0gRGF0ZS5ub3coKTtcblx0ICAgIHJlYWNoZWRIV00gPSAodGhpcy5zdG9yZU9wdGlvbnMuaGlnaFdhdGVyICE9IG51bGwpICYmIHF1ZXVlTGVuZ3RoID09PSB0aGlzLnN0b3JlT3B0aW9ucy5oaWdoV2F0ZXIgJiYgIXRoaXMuY2hlY2sod2VpZ2h0LCBub3cpO1xuXHQgICAgYmxvY2tlZCA9IHRoaXMuc3RyYXRlZ3lJc0Jsb2NrKCkgJiYgKHJlYWNoZWRIV00gfHwgdGhpcy5pc0Jsb2NrZWQobm93KSk7XG5cdCAgICBpZiAoYmxvY2tlZCkge1xuXHQgICAgICB0aGlzLl91bmJsb2NrVGltZSA9IG5vdyArIHRoaXMuY29tcHV0ZVBlbmFsdHkoKTtcblx0ICAgICAgdGhpcy5fbmV4dFJlcXVlc3QgPSB0aGlzLl91bmJsb2NrVGltZSArIHRoaXMuc3RvcmVPcHRpb25zLm1pblRpbWU7XG5cdCAgICAgIHRoaXMuaW5zdGFuY2UuX2Ryb3BBbGxRdWV1ZWQoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHJlYWNoZWRIV00sXG5cdCAgICAgIGJsb2NrZWQsXG5cdCAgICAgIHN0cmF0ZWd5OiB0aGlzLnN0b3JlT3B0aW9ucy5zdHJhdGVneVxuXHQgICAgfTtcblx0ICB9XG5cblx0ICBhc3luYyBfX2ZyZWVfXyhpbmRleCwgd2VpZ2h0KSB7XG5cdCAgICBhd2FpdCB0aGlzLnlpZWxkTG9vcCgpO1xuXHQgICAgdGhpcy5fcnVubmluZyAtPSB3ZWlnaHQ7XG5cdCAgICB0aGlzLl9kb25lICs9IHdlaWdodDtcblx0ICAgIHRoaXMuaW5zdGFuY2UuX2RyYWluQWxsKHRoaXMuY29tcHV0ZUNhcGFjaXR5KCkpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgcnVubmluZzogdGhpcy5fcnVubmluZ1xuXHQgICAgfTtcblx0ICB9XG5cblx0fTtcblxuXHR2YXIgTG9jYWxEYXRhc3RvcmVfMSA9IExvY2FsRGF0YXN0b3JlO1xuXG5cdHZhciBCb3R0bGVuZWNrRXJyb3IkMywgU3RhdGVzO1xuXG5cdEJvdHRsZW5lY2tFcnJvciQzID0gQm90dGxlbmVja0Vycm9yXzE7XG5cblx0U3RhdGVzID0gY2xhc3MgU3RhdGVzIHtcblx0ICBjb25zdHJ1Y3RvcihzdGF0dXMxKSB7XG5cdCAgICB0aGlzLnN0YXR1cyA9IHN0YXR1czE7XG5cdCAgICB0aGlzLl9qb2JzID0ge307XG5cdCAgICB0aGlzLmNvdW50cyA9IHRoaXMuc3RhdHVzLm1hcChmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIDA7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBuZXh0KGlkKSB7XG5cdCAgICB2YXIgY3VycmVudCwgbmV4dDtcblx0ICAgIGN1cnJlbnQgPSB0aGlzLl9qb2JzW2lkXTtcblx0ICAgIG5leHQgPSBjdXJyZW50ICsgMTtcblx0ICAgIGlmICgoY3VycmVudCAhPSBudWxsKSAmJiBuZXh0IDwgdGhpcy5zdGF0dXMubGVuZ3RoKSB7XG5cdCAgICAgIHRoaXMuY291bnRzW2N1cnJlbnRdLS07XG5cdCAgICAgIHRoaXMuY291bnRzW25leHRdKys7XG5cdCAgICAgIHJldHVybiB0aGlzLl9qb2JzW2lkXSsrO1xuXHQgICAgfSBlbHNlIGlmIChjdXJyZW50ICE9IG51bGwpIHtcblx0ICAgICAgdGhpcy5jb3VudHNbY3VycmVudF0tLTtcblx0ICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9qb2JzW2lkXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBzdGFydChpZCkge1xuXHQgICAgdmFyIGluaXRpYWw7XG5cdCAgICBpbml0aWFsID0gMDtcblx0ICAgIHRoaXMuX2pvYnNbaWRdID0gaW5pdGlhbDtcblx0ICAgIHJldHVybiB0aGlzLmNvdW50c1tpbml0aWFsXSsrO1xuXHQgIH1cblxuXHQgIHJlbW92ZShpZCkge1xuXHQgICAgdmFyIGN1cnJlbnQ7XG5cdCAgICBjdXJyZW50ID0gdGhpcy5fam9ic1tpZF07XG5cdCAgICBpZiAoY3VycmVudCAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuY291bnRzW2N1cnJlbnRdLS07XG5cdCAgICAgIGRlbGV0ZSB0aGlzLl9qb2JzW2lkXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjdXJyZW50ICE9IG51bGw7XG5cdCAgfVxuXG5cdCAgam9iU3RhdHVzKGlkKSB7XG5cdCAgICB2YXIgcmVmO1xuXHQgICAgcmV0dXJuIChyZWYgPSB0aGlzLnN0YXR1c1t0aGlzLl9qb2JzW2lkXV0pICE9IG51bGwgPyByZWYgOiBudWxsO1xuXHQgIH1cblxuXHQgIHN0YXR1c0pvYnMoc3RhdHVzKSB7XG5cdCAgICB2YXIgaywgcG9zLCByZWYsIHJlc3VsdHMsIHY7XG5cdCAgICBpZiAoc3RhdHVzICE9IG51bGwpIHtcblx0ICAgICAgcG9zID0gdGhpcy5zdGF0dXMuaW5kZXhPZihzdGF0dXMpO1xuXHQgICAgICBpZiAocG9zIDwgMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBCb3R0bGVuZWNrRXJyb3IkMyhgc3RhdHVzIG11c3QgYmUgb25lIG9mICR7dGhpcy5zdGF0dXMuam9pbignLCAnKX1gKTtcblx0ICAgICAgfVxuXHQgICAgICByZWYgPSB0aGlzLl9qb2JzO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIGZvciAoayBpbiByZWYpIHtcblx0ICAgICAgICB2ID0gcmVmW2tdO1xuXHQgICAgICAgIGlmICh2ID09PSBwb3MpIHtcblx0ICAgICAgICAgIHJlc3VsdHMucHVzaChrKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fam9icyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgc3RhdHVzQ291bnRzKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY291bnRzLnJlZHVjZSgoKGFjYywgdiwgaSkgPT4ge1xuXHQgICAgICBhY2NbdGhpcy5zdGF0dXNbaV1dID0gdjtcblx0ICAgICAgcmV0dXJuIGFjYztcblx0ICAgIH0pLCB7fSk7XG5cdCAgfVxuXG5cdH07XG5cblx0dmFyIFN0YXRlc18xID0gU3RhdGVzO1xuXG5cdHZhciBETExpc3QkMiwgU3luYztcblxuXHRETExpc3QkMiA9IERMTGlzdF8xO1xuXG5cdFN5bmMgPSBjbGFzcyBTeW5jIHtcblx0ICBjb25zdHJ1Y3RvcihuYW1lLCBQcm9taXNlKSB7XG5cdCAgICB0aGlzLnNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZS5iaW5kKHRoaXMpO1xuXHQgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIHRoaXMuUHJvbWlzZSA9IFByb21pc2U7XG5cdCAgICB0aGlzLl9ydW5uaW5nID0gMDtcblx0ICAgIHRoaXMuX3F1ZXVlID0gbmV3IERMTGlzdCQyKCk7XG5cdCAgfVxuXG5cdCAgaXNFbXB0eSgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDA7XG5cdCAgfVxuXG5cdCAgYXN5bmMgX3RyeVRvUnVuKCkge1xuXHQgICAgdmFyIGFyZ3MsIGNiLCBlcnJvciwgcmVqZWN0LCByZXNvbHZlLCByZXR1cm5lZCwgdGFzaztcblx0ICAgIGlmICgodGhpcy5fcnVubmluZyA8IDEpICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgdGhpcy5fcnVubmluZysrO1xuXHQgICAgICAoe3Rhc2ssIGFyZ3MsIHJlc29sdmUsIHJlamVjdH0gPSB0aGlzLl9xdWV1ZS5zaGlmdCgpKTtcblx0ICAgICAgY2IgPSAoYXdhaXQgKGFzeW5jIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICByZXR1cm5lZCA9IChhd2FpdCB0YXNrKC4uLmFyZ3MpKTtcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmV0dXJuZWQpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcblx0ICAgICAgICAgIGVycm9yID0gZXJyb3IxO1xuXHQgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICB9KSgpKTtcblx0ICAgICAgdGhpcy5fcnVubmluZy0tO1xuXHQgICAgICB0aGlzLl90cnlUb1J1bigpO1xuXHQgICAgICByZXR1cm4gY2IoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBzY2hlZHVsZSh0YXNrLCAuLi5hcmdzKSB7XG5cdCAgICB2YXIgcHJvbWlzZSwgcmVqZWN0LCByZXNvbHZlO1xuXHQgICAgcmVzb2x2ZSA9IHJlamVjdCA9IG51bGw7XG5cdCAgICBwcm9taXNlID0gbmV3IHRoaXMuUHJvbWlzZShmdW5jdGlvbihfcmVzb2x2ZSwgX3JlamVjdCkge1xuXHQgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG5cdCAgICAgIHJldHVybiByZWplY3QgPSBfcmVqZWN0O1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9xdWV1ZS5wdXNoKHt0YXNrLCBhcmdzLCByZXNvbHZlLCByZWplY3R9KTtcblx0ICAgIHRoaXMuX3RyeVRvUnVuKCk7XG5cdCAgICByZXR1cm4gcHJvbWlzZTtcblx0ICB9XG5cblx0fTtcblxuXHR2YXIgU3luY18xID0gU3luYztcblxuXHR2YXIgdmVyc2lvbiA9IFwiMi4xOS41XCI7XG5cdHZhciB2ZXJzaW9uJDEgPSB7XG5cdFx0dmVyc2lvbjogdmVyc2lvblxuXHR9O1xuXG5cdHZhciB2ZXJzaW9uJDIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0dmVyc2lvbjogdmVyc2lvbixcblx0XHRkZWZhdWx0OiB2ZXJzaW9uJDFcblx0fSk7XG5cblx0dmFyIHJlcXVpcmUkJDIgPSAoKSA9PiBjb25zb2xlLmxvZygnWW91IG11c3QgaW1wb3J0IHRoZSBmdWxsIHZlcnNpb24gb2YgQm90dGxlbmVjayBpbiBvcmRlciB0byB1c2UgdGhpcyBmZWF0dXJlLicpO1xuXG5cdHZhciByZXF1aXJlJCQzID0gKCkgPT4gY29uc29sZS5sb2coJ1lvdSBtdXN0IGltcG9ydCB0aGUgZnVsbCB2ZXJzaW9uIG9mIEJvdHRsZW5lY2sgaW4gb3JkZXIgdG8gdXNlIHRoaXMgZmVhdHVyZS4nKTtcblxuXHR2YXIgcmVxdWlyZSQkNCA9ICgpID0+IGNvbnNvbGUubG9nKCdZb3UgbXVzdCBpbXBvcnQgdGhlIGZ1bGwgdmVyc2lvbiBvZiBCb3R0bGVuZWNrIGluIG9yZGVyIHRvIHVzZSB0aGlzIGZlYXR1cmUuJyk7XG5cblx0dmFyIEV2ZW50cyQyLCBHcm91cCwgSU9SZWRpc0Nvbm5lY3Rpb24kMSwgUmVkaXNDb25uZWN0aW9uJDEsIFNjcmlwdHMkMSwgcGFyc2VyJDM7XG5cblx0cGFyc2VyJDMgPSBwYXJzZXI7XG5cblx0RXZlbnRzJDIgPSBFdmVudHNfMTtcblxuXHRSZWRpc0Nvbm5lY3Rpb24kMSA9IHJlcXVpcmUkJDI7XG5cblx0SU9SZWRpc0Nvbm5lY3Rpb24kMSA9IHJlcXVpcmUkJDM7XG5cblx0U2NyaXB0cyQxID0gcmVxdWlyZSQkNDtcblxuXHRHcm91cCA9IChmdW5jdGlvbigpIHtcblx0ICBjbGFzcyBHcm91cCB7XG5cdCAgICBjb25zdHJ1Y3RvcihsaW1pdGVyT3B0aW9ucyA9IHt9KSB7XG5cdCAgICAgIHRoaXMuZGVsZXRlS2V5ID0gdGhpcy5kZWxldGVLZXkuYmluZCh0aGlzKTtcblx0ICAgICAgdGhpcy5saW1pdGVyT3B0aW9ucyA9IGxpbWl0ZXJPcHRpb25zO1xuXHQgICAgICBwYXJzZXIkMy5sb2FkKHRoaXMubGltaXRlck9wdGlvbnMsIHRoaXMuZGVmYXVsdHMsIHRoaXMpO1xuXHQgICAgICB0aGlzLkV2ZW50cyA9IG5ldyBFdmVudHMkMih0aGlzKTtcblx0ICAgICAgdGhpcy5pbnN0YW5jZXMgPSB7fTtcblx0ICAgICAgdGhpcy5Cb3R0bGVuZWNrID0gQm90dGxlbmVja18xO1xuXHQgICAgICB0aGlzLl9zdGFydEF1dG9DbGVhbnVwKCk7XG5cdCAgICAgIHRoaXMuc2hhcmVkQ29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbiAhPSBudWxsO1xuXHQgICAgICBpZiAodGhpcy5jb25uZWN0aW9uID09IG51bGwpIHtcblx0ICAgICAgICBpZiAodGhpcy5saW1pdGVyT3B0aW9ucy5kYXRhc3RvcmUgPT09IFwicmVkaXNcIikge1xuXHQgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IFJlZGlzQ29ubmVjdGlvbiQxKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubGltaXRlck9wdGlvbnMsIHtFdmVudHM6IHRoaXMuRXZlbnRzfSkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5saW1pdGVyT3B0aW9ucy5kYXRhc3RvcmUgPT09IFwiaW9yZWRpc1wiKSB7XG5cdCAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgSU9SZWRpc0Nvbm5lY3Rpb24kMShPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxpbWl0ZXJPcHRpb25zLCB7RXZlbnRzOiB0aGlzLkV2ZW50c30pKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAga2V5KGtleSA9IFwiXCIpIHtcblx0ICAgICAgdmFyIHJlZjtcblx0ICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmluc3RhbmNlc1trZXldKSAhPSBudWxsID8gcmVmIDogKCgpID0+IHtcblx0ICAgICAgICB2YXIgbGltaXRlcjtcblx0ICAgICAgICBsaW1pdGVyID0gdGhpcy5pbnN0YW5jZXNba2V5XSA9IG5ldyB0aGlzLkJvdHRsZW5lY2soT2JqZWN0LmFzc2lnbih0aGlzLmxpbWl0ZXJPcHRpb25zLCB7XG5cdCAgICAgICAgICBpZDogYCR7dGhpcy5pZH0tJHtrZXl9YCxcblx0ICAgICAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcblx0ICAgICAgICAgIGNvbm5lY3Rpb246IHRoaXMuY29ubmVjdGlvblxuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICB0aGlzLkV2ZW50cy50cmlnZ2VyKFwiY3JlYXRlZFwiLCBsaW1pdGVyLCBrZXkpO1xuXHQgICAgICAgIHJldHVybiBsaW1pdGVyO1xuXHQgICAgICB9KSgpO1xuXHQgICAgfVxuXG5cdCAgICBhc3luYyBkZWxldGVLZXkoa2V5ID0gXCJcIikge1xuXHQgICAgICB2YXIgZGVsZXRlZCwgaW5zdGFuY2U7XG5cdCAgICAgIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXNba2V5XTtcblx0ICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuXHQgICAgICAgIGRlbGV0ZWQgPSAoYXdhaXQgdGhpcy5jb25uZWN0aW9uLl9fcnVuQ29tbWFuZF9fKFsnZGVsJywgLi4uU2NyaXB0cyQxLmFsbEtleXMoYCR7dGhpcy5pZH0tJHtrZXl9YCldKSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcblx0ICAgICAgICBkZWxldGUgdGhpcy5pbnN0YW5jZXNba2V5XTtcblx0ICAgICAgICBhd2FpdCBpbnN0YW5jZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIChpbnN0YW5jZSAhPSBudWxsKSB8fCBkZWxldGVkID4gMDtcblx0ICAgIH1cblxuXHQgICAgbGltaXRlcnMoKSB7XG5cdCAgICAgIHZhciBrLCByZWYsIHJlc3VsdHMsIHY7XG5cdCAgICAgIHJlZiA9IHRoaXMuaW5zdGFuY2VzO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIGZvciAoayBpbiByZWYpIHtcblx0ICAgICAgICB2ID0gcmVmW2tdO1xuXHQgICAgICAgIHJlc3VsdHMucHVzaCh7XG5cdCAgICAgICAgICBrZXk6IGssXG5cdCAgICAgICAgICBsaW1pdGVyOiB2XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICB9XG5cblx0ICAgIGtleXMoKSB7XG5cdCAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmluc3RhbmNlcyk7XG5cdCAgICB9XG5cblx0ICAgIGFzeW5jIGNsdXN0ZXJLZXlzKCkge1xuXHQgICAgICB2YXIgY3Vyc29yLCBlbmQsIGZvdW5kLCBpLCBrLCBrZXlzLCBsZW4sIG5leHQsIHN0YXJ0O1xuXHQgICAgICBpZiAodGhpcy5jb25uZWN0aW9uID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5Qcm9taXNlLnJlc29sdmUodGhpcy5rZXlzKCkpO1xuXHQgICAgICB9XG5cdCAgICAgIGtleXMgPSBbXTtcblx0ICAgICAgY3Vyc29yID0gbnVsbDtcblx0ICAgICAgc3RhcnQgPSBgYl8ke3RoaXMuaWR9LWAubGVuZ3RoO1xuXHQgICAgICBlbmQgPSBcIl9zZXR0aW5nc1wiLmxlbmd0aDtcblx0ICAgICAgd2hpbGUgKGN1cnNvciAhPT0gMCkge1xuXHQgICAgICAgIFtuZXh0LCBmb3VuZF0gPSAoYXdhaXQgdGhpcy5jb25uZWN0aW9uLl9fcnVuQ29tbWFuZF9fKFtcInNjYW5cIiwgY3Vyc29yICE9IG51bGwgPyBjdXJzb3IgOiAwLCBcIm1hdGNoXCIsIGBiXyR7dGhpcy5pZH0tKl9zZXR0aW5nc2AsIFwiY291bnRcIiwgMTAwMDBdKSk7XG5cdCAgICAgICAgY3Vyc29yID0gfn5uZXh0O1xuXHQgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGZvdW5kLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICBrID0gZm91bmRbaV07XG5cdCAgICAgICAgICBrZXlzLnB1c2goay5zbGljZShzdGFydCwgLWVuZCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4ga2V5cztcblx0ICAgIH1cblxuXHQgICAgX3N0YXJ0QXV0b0NsZWFudXAoKSB7XG5cdCAgICAgIHZhciBiYXNlO1xuXHQgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuXHQgICAgICByZXR1cm4gdHlwZW9mIChiYXNlID0gKHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYygpID0+IHtcblx0ICAgICAgICB2YXIgZSwgaywgcmVmLCByZXN1bHRzLCB0aW1lLCB2O1xuXHQgICAgICAgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHQgICAgICAgIHJlZiA9IHRoaXMuaW5zdGFuY2VzO1xuXHQgICAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICBmb3IgKGsgaW4gcmVmKSB7XG5cdCAgICAgICAgICB2ID0gcmVmW2tdO1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKChhd2FpdCB2Ll9zdG9yZS5fX2dyb3VwQ2hlY2tfXyh0aW1lKSkpIHtcblx0ICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5kZWxldGVLZXkoaykpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBlID0gZXJyb3I7XG5cdCAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2LkV2ZW50cy50cmlnZ2VyKFwiZXJyb3JcIiwgZSkpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgICAgfSwgdGhpcy50aW1lb3V0IC8gMikpKS51bnJlZiA9PT0gXCJmdW5jdGlvblwiID8gYmFzZS51bnJlZigpIDogdm9pZCAwO1xuXHQgICAgfVxuXG5cdCAgICB1cGRhdGVTZXR0aW5ncyhvcHRpb25zID0ge30pIHtcblx0ICAgICAgcGFyc2VyJDMub3ZlcndyaXRlKG9wdGlvbnMsIHRoaXMuZGVmYXVsdHMsIHRoaXMpO1xuXHQgICAgICBwYXJzZXIkMy5vdmVyd3JpdGUob3B0aW9ucywgb3B0aW9ucywgdGhpcy5saW1pdGVyT3B0aW9ucyk7XG5cdCAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQgIT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9zdGFydEF1dG9DbGVhbnVwKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZGlzY29ubmVjdChmbHVzaCA9IHRydWUpIHtcblx0ICAgICAgdmFyIHJlZjtcblx0ICAgICAgaWYgKCF0aGlzLnNoYXJlZENvbm5lY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMuY29ubmVjdGlvbikgIT0gbnVsbCA/IHJlZi5kaXNjb25uZWN0KGZsdXNoKSA6IHZvaWQgMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgfVxuXHQgIEdyb3VwLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcblx0ICAgIHRpbWVvdXQ6IDEwMDAgKiA2MCAqIDUsXG5cdCAgICBjb25uZWN0aW9uOiBudWxsLFxuXHQgICAgUHJvbWlzZTogUHJvbWlzZSxcblx0ICAgIGlkOiBcImdyb3VwLWtleVwiXG5cdCAgfTtcblxuXHQgIHJldHVybiBHcm91cDtcblxuXHR9KS5jYWxsKGNvbW1vbmpzR2xvYmFsKTtcblxuXHR2YXIgR3JvdXBfMSA9IEdyb3VwO1xuXG5cdHZhciBCYXRjaGVyLCBFdmVudHMkMywgcGFyc2VyJDQ7XG5cblx0cGFyc2VyJDQgPSBwYXJzZXI7XG5cblx0RXZlbnRzJDMgPSBFdmVudHNfMTtcblxuXHRCYXRjaGVyID0gKGZ1bmN0aW9uKCkge1xuXHQgIGNsYXNzIEJhdGNoZXIge1xuXHQgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdCAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdCAgICAgIHBhcnNlciQ0LmxvYWQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRzLCB0aGlzKTtcblx0ICAgICAgdGhpcy5FdmVudHMgPSBuZXcgRXZlbnRzJDModGhpcyk7XG5cdCAgICAgIHRoaXMuX2FyciA9IFtdO1xuXHQgICAgICB0aGlzLl9yZXNldFByb21pc2UoKTtcblx0ICAgICAgdGhpcy5fbGFzdEZsdXNoID0gRGF0ZS5ub3coKTtcblx0ICAgIH1cblxuXHQgICAgX3Jlc2V0UHJvbWlzZSgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UgPSBuZXcgdGhpcy5Qcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlID0gcmVzO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgX2ZsdXNoKCkge1xuXHQgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG5cdCAgICAgIHRoaXMuX2xhc3RGbHVzaCA9IERhdGUubm93KCk7XG5cdCAgICAgIHRoaXMuX3Jlc29sdmUoKTtcblx0ICAgICAgdGhpcy5FdmVudHMudHJpZ2dlcihcImJhdGNoXCIsIHRoaXMuX2Fycik7XG5cdCAgICAgIHRoaXMuX2FyciA9IFtdO1xuXHQgICAgICByZXR1cm4gdGhpcy5fcmVzZXRQcm9taXNlKCk7XG5cdCAgICB9XG5cblx0ICAgIGFkZChkYXRhKSB7XG5cdCAgICAgIHZhciByZXQ7XG5cdCAgICAgIHRoaXMuX2Fyci5wdXNoKGRhdGEpO1xuXHQgICAgICByZXQgPSB0aGlzLl9wcm9taXNlO1xuXHQgICAgICBpZiAodGhpcy5fYXJyLmxlbmd0aCA9PT0gdGhpcy5tYXhTaXplKSB7XG5cdCAgICAgICAgdGhpcy5fZmx1c2goKTtcblx0ICAgICAgfSBlbHNlIGlmICgodGhpcy5tYXhUaW1lICE9IG51bGwpICYmIHRoaXMuX2Fyci5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5fZmx1c2goKTtcblx0ICAgICAgICB9LCB0aGlzLm1heFRpbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXQ7XG5cdCAgICB9XG5cblx0ICB9XG5cdCAgQmF0Y2hlci5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG5cdCAgICBtYXhUaW1lOiBudWxsLFxuXHQgICAgbWF4U2l6ZTogbnVsbCxcblx0ICAgIFByb21pc2U6IFByb21pc2Vcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEJhdGNoZXI7XG5cblx0fSkuY2FsbChjb21tb25qc0dsb2JhbCk7XG5cblx0dmFyIEJhdGNoZXJfMSA9IEJhdGNoZXI7XG5cblx0dmFyIHJlcXVpcmUkJDQkMSA9ICgpID0+IGNvbnNvbGUubG9nKCdZb3UgbXVzdCBpbXBvcnQgdGhlIGZ1bGwgdmVyc2lvbiBvZiBCb3R0bGVuZWNrIGluIG9yZGVyIHRvIHVzZSB0aGlzIGZlYXR1cmUuJyk7XG5cblx0dmFyIHJlcXVpcmUkJDggPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKHZlcnNpb24kMik7XG5cblx0dmFyIEJvdHRsZW5lY2ssIERFRkFVTFRfUFJJT1JJVFkkMSwgRXZlbnRzJDQsIEpvYiQxLCBMb2NhbERhdGFzdG9yZSQxLCBOVU1fUFJJT1JJVElFUyQxLCBRdWV1ZXMkMSwgUmVkaXNEYXRhc3RvcmUkMSwgU3RhdGVzJDEsIFN5bmMkMSwgcGFyc2VyJDUsXG5cdCAgc3BsaWNlID0gW10uc3BsaWNlO1xuXG5cdE5VTV9QUklPUklUSUVTJDEgPSAxMDtcblxuXHRERUZBVUxUX1BSSU9SSVRZJDEgPSA1O1xuXG5cdHBhcnNlciQ1ID0gcGFyc2VyO1xuXG5cdFF1ZXVlcyQxID0gUXVldWVzXzE7XG5cblx0Sm9iJDEgPSBKb2JfMTtcblxuXHRMb2NhbERhdGFzdG9yZSQxID0gTG9jYWxEYXRhc3RvcmVfMTtcblxuXHRSZWRpc0RhdGFzdG9yZSQxID0gcmVxdWlyZSQkNCQxO1xuXG5cdEV2ZW50cyQ0ID0gRXZlbnRzXzE7XG5cblx0U3RhdGVzJDEgPSBTdGF0ZXNfMTtcblxuXHRTeW5jJDEgPSBTeW5jXzE7XG5cblx0Qm90dGxlbmVjayA9IChmdW5jdGlvbigpIHtcblx0ICBjbGFzcyBCb3R0bGVuZWNrIHtcblx0ICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgLi4uaW52YWxpZCkge1xuXHQgICAgICB2YXIgc3RvcmVJbnN0YW5jZU9wdGlvbnMsIHN0b3JlT3B0aW9ucztcblx0ICAgICAgdGhpcy5fYWRkVG9RdWV1ZSA9IHRoaXMuX2FkZFRvUXVldWUuYmluZCh0aGlzKTtcblx0ICAgICAgdGhpcy5fdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIGludmFsaWQpO1xuXHQgICAgICBwYXJzZXIkNS5sb2FkKG9wdGlvbnMsIHRoaXMuaW5zdGFuY2VEZWZhdWx0cywgdGhpcyk7XG5cdCAgICAgIHRoaXMuX3F1ZXVlcyA9IG5ldyBRdWV1ZXMkMShOVU1fUFJJT1JJVElFUyQxKTtcblx0ICAgICAgdGhpcy5fc2NoZWR1bGVkID0ge307XG5cdCAgICAgIHRoaXMuX3N0YXRlcyA9IG5ldyBTdGF0ZXMkMShbXCJSRUNFSVZFRFwiLCBcIlFVRVVFRFwiLCBcIlJVTk5JTkdcIiwgXCJFWEVDVVRJTkdcIl0uY29uY2F0KHRoaXMudHJhY2tEb25lU3RhdHVzID8gW1wiRE9ORVwiXSA6IFtdKSk7XG5cdCAgICAgIHRoaXMuX2xpbWl0ZXIgPSBudWxsO1xuXHQgICAgICB0aGlzLkV2ZW50cyA9IG5ldyBFdmVudHMkNCh0aGlzKTtcblx0ICAgICAgdGhpcy5fc3VibWl0TG9jayA9IG5ldyBTeW5jJDEoXCJzdWJtaXRcIiwgdGhpcy5Qcm9taXNlKTtcblx0ICAgICAgdGhpcy5fcmVnaXN0ZXJMb2NrID0gbmV3IFN5bmMkMShcInJlZ2lzdGVyXCIsIHRoaXMuUHJvbWlzZSk7XG5cdCAgICAgIHN0b3JlT3B0aW9ucyA9IHBhcnNlciQ1LmxvYWQob3B0aW9ucywgdGhpcy5zdG9yZURlZmF1bHRzLCB7fSk7XG5cdCAgICAgIHRoaXMuX3N0b3JlID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGlmICh0aGlzLmRhdGFzdG9yZSA9PT0gXCJyZWRpc1wiIHx8IHRoaXMuZGF0YXN0b3JlID09PSBcImlvcmVkaXNcIiB8fCAodGhpcy5jb25uZWN0aW9uICE9IG51bGwpKSB7XG5cdCAgICAgICAgICBzdG9yZUluc3RhbmNlT3B0aW9ucyA9IHBhcnNlciQ1LmxvYWQob3B0aW9ucywgdGhpcy5yZWRpc1N0b3JlRGVmYXVsdHMsIHt9KTtcblx0ICAgICAgICAgIHJldHVybiBuZXcgUmVkaXNEYXRhc3RvcmUkMSh0aGlzLCBzdG9yZU9wdGlvbnMsIHN0b3JlSW5zdGFuY2VPcHRpb25zKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YXN0b3JlID09PSBcImxvY2FsXCIpIHtcblx0ICAgICAgICAgIHN0b3JlSW5zdGFuY2VPcHRpb25zID0gcGFyc2VyJDUubG9hZChvcHRpb25zLCB0aGlzLmxvY2FsU3RvcmVEZWZhdWx0cywge30pO1xuXHQgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhbERhdGFzdG9yZSQxKHRoaXMsIHN0b3JlT3B0aW9ucywgc3RvcmVJbnN0YW5jZU9wdGlvbnMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgQm90dGxlbmVjay5wcm90b3R5cGUuQm90dGxlbmVja0Vycm9yKGBJbnZhbGlkIGRhdGFzdG9yZSB0eXBlOiAke3RoaXMuZGF0YXN0b3JlfWApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSkuY2FsbCh0aGlzKTtcblx0ICAgICAgdGhpcy5fcXVldWVzLm9uKFwibGVmdHplcm9cIiwgKCkgPT4ge1xuXHQgICAgICAgIHZhciByZWY7XG5cdCAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLl9zdG9yZS5oZWFydGJlYXQpICE9IG51bGwgPyB0eXBlb2YgcmVmLnJlZiA9PT0gXCJmdW5jdGlvblwiID8gcmVmLnJlZigpIDogdm9pZCAwIDogdm9pZCAwO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5fcXVldWVzLm9uKFwiemVyb1wiLCAoKSA9PiB7XG5cdCAgICAgICAgdmFyIHJlZjtcblx0ICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMuX3N0b3JlLmhlYXJ0YmVhdCkgIT0gbnVsbCA/IHR5cGVvZiByZWYudW5yZWYgPT09IFwiZnVuY3Rpb25cIiA/IHJlZi51bnJlZigpIDogdm9pZCAwIDogdm9pZCAwO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgX3ZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBpbnZhbGlkKSB7XG5cdCAgICAgIGlmICghKChvcHRpb25zICE9IG51bGwpICYmIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIGludmFsaWQubGVuZ3RoID09PSAwKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBCb3R0bGVuZWNrLnByb3RvdHlwZS5Cb3R0bGVuZWNrRXJyb3IoXCJCb3R0bGVuZWNrIHYyIHRha2VzIGEgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4gUmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL1NHcm9uZGluL2JvdHRsZW5lY2sjdXBncmFkaW5nLXRvLXYyIGlmIHlvdSdyZSB1cGdyYWRpbmcgZnJvbSBCb3R0bGVuZWNrIHYxLlwiKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZWFkeSgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLnJlYWR5O1xuXHQgICAgfVxuXG5cdCAgICBjbGllbnRzKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuY2xpZW50cztcblx0ICAgIH1cblxuXHQgICAgY2hhbm5lbCgpIHtcblx0ICAgICAgcmV0dXJuIGBiXyR7dGhpcy5pZH1gO1xuXHQgICAgfVxuXG5cdCAgICBjaGFubmVsX2NsaWVudCgpIHtcblx0ICAgICAgcmV0dXJuIGBiXyR7dGhpcy5pZH1fJHt0aGlzLl9zdG9yZS5jbGllbnRJZH1gO1xuXHQgICAgfVxuXG5cdCAgICBwdWJsaXNoKG1lc3NhZ2UpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLl9fcHVibGlzaF9fKG1lc3NhZ2UpO1xuXHQgICAgfVxuXG5cdCAgICBkaXNjb25uZWN0KGZsdXNoID0gdHJ1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuX19kaXNjb25uZWN0X18oZmx1c2gpO1xuXHQgICAgfVxuXG5cdCAgICBjaGFpbihfbGltaXRlcikge1xuXHQgICAgICB0aGlzLl9saW1pdGVyID0gX2xpbWl0ZXI7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBxdWV1ZWQocHJpb3JpdHkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlcy5xdWV1ZWQocHJpb3JpdHkpO1xuXHQgICAgfVxuXG5cdCAgICBjbHVzdGVyUXVldWVkKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuX19xdWV1ZWRfXygpO1xuXHQgICAgfVxuXG5cdCAgICBlbXB0eSgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucXVldWVkKCkgPT09IDAgJiYgdGhpcy5fc3VibWl0TG9jay5pc0VtcHR5KCk7XG5cdCAgICB9XG5cblx0ICAgIHJ1bm5pbmcoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5fX3J1bm5pbmdfXygpO1xuXHQgICAgfVxuXG5cdCAgICBkb25lKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuX19kb25lX18oKTtcblx0ICAgIH1cblxuXHQgICAgam9iU3RhdHVzKGlkKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXMuam9iU3RhdHVzKGlkKTtcblx0ICAgIH1cblxuXHQgICAgam9icyhzdGF0dXMpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlcy5zdGF0dXNKb2JzKHN0YXR1cyk7XG5cdCAgICB9XG5cblx0ICAgIGNvdW50cygpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlcy5zdGF0dXNDb3VudHMoKTtcblx0ICAgIH1cblxuXHQgICAgX3JhbmRvbUluZGV4KCkge1xuXHQgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cdCAgICB9XG5cblx0ICAgIGNoZWNrKHdlaWdodCA9IDEpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLl9fY2hlY2tfXyh3ZWlnaHQpO1xuXHQgICAgfVxuXG5cdCAgICBfY2xlYXJHbG9iYWxTdGF0ZShpbmRleCkge1xuXHQgICAgICBpZiAodGhpcy5fc2NoZWR1bGVkW2luZGV4XSAhPSBudWxsKSB7XG5cdCAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3NjaGVkdWxlZFtpbmRleF0uZXhwaXJhdGlvbik7XG5cdCAgICAgICAgZGVsZXRlIHRoaXMuX3NjaGVkdWxlZFtpbmRleF07XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGFzeW5jIF9mcmVlKGluZGV4LCBqb2IsIG9wdGlvbnMsIGV2ZW50SW5mbykge1xuXHQgICAgICB2YXIgZSwgcnVubmluZztcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICAoe3J1bm5pbmd9ID0gKGF3YWl0IHRoaXMuX3N0b3JlLl9fZnJlZV9fKGluZGV4LCBvcHRpb25zLndlaWdodCkpKTtcblx0ICAgICAgICB0aGlzLkV2ZW50cy50cmlnZ2VyKFwiZGVidWdcIiwgYEZyZWVkICR7b3B0aW9ucy5pZH1gLCBldmVudEluZm8pO1xuXHQgICAgICAgIGlmIChydW5uaW5nID09PSAwICYmIHRoaXMuZW1wdHkoKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXMuRXZlbnRzLnRyaWdnZXIoXCJpZGxlXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG5cdCAgICAgICAgZSA9IGVycm9yMTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5FdmVudHMudHJpZ2dlcihcImVycm9yXCIsIGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIF9ydW4oaW5kZXgsIGpvYiwgd2FpdCkge1xuXHQgICAgICB2YXIgY2xlYXJHbG9iYWxTdGF0ZSwgZnJlZSwgcnVuO1xuXHQgICAgICBqb2IuZG9SdW4oKTtcblx0ICAgICAgY2xlYXJHbG9iYWxTdGF0ZSA9IHRoaXMuX2NsZWFyR2xvYmFsU3RhdGUuYmluZCh0aGlzLCBpbmRleCk7XG5cdCAgICAgIHJ1biA9IHRoaXMuX3J1bi5iaW5kKHRoaXMsIGluZGV4LCBqb2IpO1xuXHQgICAgICBmcmVlID0gdGhpcy5fZnJlZS5iaW5kKHRoaXMsIGluZGV4LCBqb2IpO1xuXHQgICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVkW2luZGV4XSA9IHtcblx0ICAgICAgICB0aW1lb3V0OiBzZXRUaW1lb3V0KCgpID0+IHtcblx0ICAgICAgICAgIHJldHVybiBqb2IuZG9FeGVjdXRlKHRoaXMuX2xpbWl0ZXIsIGNsZWFyR2xvYmFsU3RhdGUsIHJ1biwgZnJlZSk7XG5cdCAgICAgICAgfSwgd2FpdCksXG5cdCAgICAgICAgZXhwaXJhdGlvbjogam9iLm9wdGlvbnMuZXhwaXJhdGlvbiAhPSBudWxsID8gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgIHJldHVybiBqb2IuZG9FeHBpcmUoY2xlYXJHbG9iYWxTdGF0ZSwgcnVuLCBmcmVlKTtcblx0ICAgICAgICB9LCB3YWl0ICsgam9iLm9wdGlvbnMuZXhwaXJhdGlvbikgOiB2b2lkIDAsXG5cdCAgICAgICAgam9iOiBqb2Jcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgX2RyYWluT25lKGNhcGFjaXR5KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlckxvY2suc2NoZWR1bGUoKCkgPT4ge1xuXHQgICAgICAgIHZhciBhcmdzLCBpbmRleCwgbmV4dCwgb3B0aW9ucywgcXVldWU7XG5cdCAgICAgICAgaWYgKHRoaXMucXVldWVkKCkgPT09IDApIHtcblx0ICAgICAgICAgIHJldHVybiB0aGlzLlByb21pc2UucmVzb2x2ZShudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcXVldWUgPSB0aGlzLl9xdWV1ZXMuZ2V0Rmlyc3QoKTtcblx0ICAgICAgICAoe29wdGlvbnMsIGFyZ3N9ID0gbmV4dCA9IHF1ZXVlLmZpcnN0KCkpO1xuXHQgICAgICAgIGlmICgoY2FwYWNpdHkgIT0gbnVsbCkgJiYgb3B0aW9ucy53ZWlnaHQgPiBjYXBhY2l0eSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXMuUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLkV2ZW50cy50cmlnZ2VyKFwiZGVidWdcIiwgYERyYWluaW5nICR7b3B0aW9ucy5pZH1gLCB7YXJncywgb3B0aW9uc30pO1xuXHQgICAgICAgIGluZGV4ID0gdGhpcy5fcmFuZG9tSW5kZXgoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuX19yZWdpc3Rlcl9fKGluZGV4LCBvcHRpb25zLndlaWdodCwgb3B0aW9ucy5leHBpcmF0aW9uKS50aGVuKCh7c3VjY2Vzcywgd2FpdCwgcmVzZXJ2b2lyfSkgPT4ge1xuXHQgICAgICAgICAgdmFyIGVtcHR5O1xuXHQgICAgICAgICAgdGhpcy5FdmVudHMudHJpZ2dlcihcImRlYnVnXCIsIGBEcmFpbmVkICR7b3B0aW9ucy5pZH1gLCB7c3VjY2VzcywgYXJncywgb3B0aW9uc30pO1xuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcblx0ICAgICAgICAgICAgcXVldWUuc2hpZnQoKTtcblx0ICAgICAgICAgICAgZW1wdHkgPSB0aGlzLmVtcHR5KCk7XG5cdCAgICAgICAgICAgIGlmIChlbXB0eSkge1xuXHQgICAgICAgICAgICAgIHRoaXMuRXZlbnRzLnRyaWdnZXIoXCJlbXB0eVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocmVzZXJ2b2lyID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5FdmVudHMudHJpZ2dlcihcImRlcGxldGVkXCIsIGVtcHR5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9ydW4oaW5kZXgsIG5leHQsIHdhaXQpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5Qcm9taXNlLnJlc29sdmUob3B0aW9ucy53ZWlnaHQpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgX2RyYWluQWxsKGNhcGFjaXR5LCB0b3RhbCA9IDApIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2RyYWluT25lKGNhcGFjaXR5KS50aGVuKChkcmFpbmVkKSA9PiB7XG5cdCAgICAgICAgdmFyIG5ld0NhcGFjaXR5O1xuXHQgICAgICAgIGlmIChkcmFpbmVkICE9IG51bGwpIHtcblx0ICAgICAgICAgIG5ld0NhcGFjaXR5ID0gY2FwYWNpdHkgIT0gbnVsbCA/IGNhcGFjaXR5IC0gZHJhaW5lZCA6IGNhcGFjaXR5O1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWluQWxsKG5ld0NhcGFjaXR5LCB0b3RhbCArIGRyYWluZWQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5Qcm9taXNlLnJlc29sdmUodG90YWwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSkuY2F0Y2goKGUpID0+IHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5FdmVudHMudHJpZ2dlcihcImVycm9yXCIsIGUpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgX2Ryb3BBbGxRdWV1ZWQobWVzc2FnZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcXVldWVzLnNoaWZ0QWxsKGZ1bmN0aW9uKGpvYikge1xuXHQgICAgICAgIHJldHVybiBqb2IuZG9Ecm9wKHttZXNzYWdlfSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBzdG9wKG9wdGlvbnMgPSB7fSkge1xuXHQgICAgICB2YXIgZG9uZSwgd2FpdEZvckV4ZWN1dGluZztcblx0ICAgICAgb3B0aW9ucyA9IHBhcnNlciQ1LmxvYWQob3B0aW9ucywgdGhpcy5zdG9wRGVmYXVsdHMpO1xuXHQgICAgICB3YWl0Rm9yRXhlY3V0aW5nID0gKGF0KSA9PiB7XG5cdCAgICAgICAgdmFyIGZpbmlzaGVkO1xuXHQgICAgICAgIGZpbmlzaGVkID0gKCkgPT4ge1xuXHQgICAgICAgICAgdmFyIGNvdW50cztcblx0ICAgICAgICAgIGNvdW50cyA9IHRoaXMuX3N0YXRlcy5jb3VudHM7XG5cdCAgICAgICAgICByZXR1cm4gKGNvdW50c1swXSArIGNvdW50c1sxXSArIGNvdW50c1syXSArIGNvdW50c1szXSkgPT09IGF0O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHQgICAgICAgICAgaWYgKGZpbmlzaGVkKCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKFwiZG9uZVwiLCAoKSA9PiB7XG5cdCAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkKCkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwiZG9uZVwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfTtcblx0ICAgICAgZG9uZSA9IG9wdGlvbnMuZHJvcFdhaXRpbmdKb2JzID8gKHRoaXMuX3J1biA9IGZ1bmN0aW9uKGluZGV4LCBuZXh0KSB7XG5cdCAgICAgICAgcmV0dXJuIG5leHQuZG9Ecm9wKHtcblx0ICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMuZHJvcEVycm9yTWVzc2FnZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LCB0aGlzLl9kcmFpbk9uZSA9ICgpID0+IHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5Qcm9taXNlLnJlc29sdmUobnVsbCk7XG5cdCAgICAgIH0sIHRoaXMuX3JlZ2lzdGVyTG9jay5zY2hlZHVsZSgoKSA9PiB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3N1Ym1pdExvY2suc2NoZWR1bGUoKCkgPT4ge1xuXHQgICAgICAgICAgdmFyIGssIHJlZiwgdjtcblx0ICAgICAgICAgIHJlZiA9IHRoaXMuX3NjaGVkdWxlZDtcblx0ICAgICAgICAgIGZvciAoayBpbiByZWYpIHtcblx0ICAgICAgICAgICAgdiA9IHJlZltrXTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuam9iU3RhdHVzKHYuam9iLm9wdGlvbnMuaWQpID09PSBcIlJVTk5JTkdcIikge1xuXHQgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh2LnRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh2LmV4cGlyYXRpb24pO1xuXHQgICAgICAgICAgICAgIHYuam9iLmRvRHJvcCh7XG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLmRyb3BFcnJvck1lc3NhZ2Vcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdGhpcy5fZHJvcEFsbFF1ZXVlZChvcHRpb25zLmRyb3BFcnJvck1lc3NhZ2UpO1xuXHQgICAgICAgICAgcmV0dXJuIHdhaXRGb3JFeGVjdXRpbmcoMCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0pKSA6IHRoaXMuc2NoZWR1bGUoe1xuXHQgICAgICAgIHByaW9yaXR5OiBOVU1fUFJJT1JJVElFUyQxIC0gMSxcblx0ICAgICAgICB3ZWlnaHQ6IDBcblx0ICAgICAgfSwgKCkgPT4ge1xuXHQgICAgICAgIHJldHVybiB3YWl0Rm9yRXhlY3V0aW5nKDEpO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5fcmVjZWl2ZSA9IGZ1bmN0aW9uKGpvYikge1xuXHQgICAgICAgIHJldHVybiBqb2IuX3JlamVjdChuZXcgQm90dGxlbmVjay5wcm90b3R5cGUuQm90dGxlbmVja0Vycm9yKG9wdGlvbnMuZW5xdWV1ZUVycm9yTWVzc2FnZSkpO1xuXHQgICAgICB9O1xuXHQgICAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuUHJvbWlzZS5yZWplY3QobmV3IEJvdHRsZW5lY2sucHJvdG90eXBlLkJvdHRsZW5lY2tFcnJvcihcInN0b3AoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKSk7XG5cdCAgICAgIH07XG5cdCAgICAgIHJldHVybiBkb25lO1xuXHQgICAgfVxuXG5cdCAgICBhc3luYyBfYWRkVG9RdWV1ZShqb2IpIHtcblx0ICAgICAgdmFyIGFyZ3MsIGJsb2NrZWQsIGVycm9yLCBvcHRpb25zLCByZWFjaGVkSFdNLCBzaGlmdGVkLCBzdHJhdGVneTtcblx0ICAgICAgKHthcmdzLCBvcHRpb25zfSA9IGpvYik7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgKHtyZWFjaGVkSFdNLCBibG9ja2VkLCBzdHJhdGVneX0gPSAoYXdhaXQgdGhpcy5fc3RvcmUuX19zdWJtaXRfXyh0aGlzLnF1ZXVlZCgpLCBvcHRpb25zLndlaWdodCkpKTtcblx0ICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG5cdCAgICAgICAgZXJyb3IgPSBlcnJvcjE7XG5cdCAgICAgICAgdGhpcy5FdmVudHMudHJpZ2dlcihcImRlYnVnXCIsIGBDb3VsZCBub3QgcXVldWUgJHtvcHRpb25zLmlkfWAsIHthcmdzLCBvcHRpb25zLCBlcnJvcn0pO1xuXHQgICAgICAgIGpvYi5kb0Ryb3Aoe2Vycm9yfSk7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChibG9ja2VkKSB7XG5cdCAgICAgICAgam9iLmRvRHJvcCgpO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9IGVsc2UgaWYgKHJlYWNoZWRIV00pIHtcblx0ICAgICAgICBzaGlmdGVkID0gc3RyYXRlZ3kgPT09IEJvdHRsZW5lY2sucHJvdG90eXBlLnN0cmF0ZWd5LkxFQUsgPyB0aGlzLl9xdWV1ZXMuc2hpZnRMYXN0RnJvbShvcHRpb25zLnByaW9yaXR5KSA6IHN0cmF0ZWd5ID09PSBCb3R0bGVuZWNrLnByb3RvdHlwZS5zdHJhdGVneS5PVkVSRkxPV19QUklPUklUWSA/IHRoaXMuX3F1ZXVlcy5zaGlmdExhc3RGcm9tKG9wdGlvbnMucHJpb3JpdHkgKyAxKSA6IHN0cmF0ZWd5ID09PSBCb3R0bGVuZWNrLnByb3RvdHlwZS5zdHJhdGVneS5PVkVSRkxPVyA/IGpvYiA6IHZvaWQgMDtcblx0ICAgICAgICBpZiAoc2hpZnRlZCAhPSBudWxsKSB7XG5cdCAgICAgICAgICBzaGlmdGVkLmRvRHJvcCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoKHNoaWZ0ZWQgPT0gbnVsbCkgfHwgc3RyYXRlZ3kgPT09IEJvdHRsZW5lY2sucHJvdG90eXBlLnN0cmF0ZWd5Lk9WRVJGTE9XKSB7XG5cdCAgICAgICAgICBpZiAoc2hpZnRlZCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGpvYi5kb0Ryb3AoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiByZWFjaGVkSFdNO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBqb2IuZG9RdWV1ZShyZWFjaGVkSFdNLCBibG9ja2VkKTtcblx0ICAgICAgdGhpcy5fcXVldWVzLnB1c2goam9iKTtcblx0ICAgICAgYXdhaXQgdGhpcy5fZHJhaW5BbGwoKTtcblx0ICAgICAgcmV0dXJuIHJlYWNoZWRIV007XG5cdCAgICB9XG5cblx0ICAgIF9yZWNlaXZlKGpvYikge1xuXHQgICAgICBpZiAodGhpcy5fc3RhdGVzLmpvYlN0YXR1cyhqb2Iub3B0aW9ucy5pZCkgIT0gbnVsbCkge1xuXHQgICAgICAgIGpvYi5fcmVqZWN0KG5ldyBCb3R0bGVuZWNrLnByb3RvdHlwZS5Cb3R0bGVuZWNrRXJyb3IoYEEgam9iIHdpdGggdGhlIHNhbWUgaWQgYWxyZWFkeSBleGlzdHMgKGlkPSR7am9iLm9wdGlvbnMuaWR9KWApKTtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgam9iLmRvUmVjZWl2ZSgpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9zdWJtaXRMb2NrLnNjaGVkdWxlKHRoaXMuX2FkZFRvUXVldWUsIGpvYik7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgc3VibWl0KC4uLmFyZ3MpIHtcblx0ICAgICAgdmFyIGNiLCBmbiwgam9iLCBvcHRpb25zLCByZWYsIHJlZjEsIHRhc2s7XG5cdCAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgcmVmID0gYXJncywgW2ZuLCAuLi5hcmdzXSA9IHJlZiwgW2NiXSA9IHNwbGljZS5jYWxsKGFyZ3MsIC0xKTtcblx0ICAgICAgICBvcHRpb25zID0gcGFyc2VyJDUubG9hZCh7fSwgdGhpcy5qb2JEZWZhdWx0cyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVmMSA9IGFyZ3MsIFtvcHRpb25zLCBmbiwgLi4uYXJnc10gPSByZWYxLCBbY2JdID0gc3BsaWNlLmNhbGwoYXJncywgLTEpO1xuXHQgICAgICAgIG9wdGlvbnMgPSBwYXJzZXIkNS5sb2FkKG9wdGlvbnMsIHRoaXMuam9iRGVmYXVsdHMpO1xuXHQgICAgICB9XG5cdCAgICAgIHRhc2sgPSAoLi4uYXJncykgPT4ge1xuXHQgICAgICAgIHJldHVybiBuZXcgdGhpcy5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MsIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChhcmdzWzBdICE9IG51bGwgPyByZWplY3QgOiByZXNvbHZlKShhcmdzKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9O1xuXHQgICAgICBqb2IgPSBuZXcgSm9iJDEodGFzaywgYXJncywgb3B0aW9ucywgdGhpcy5qb2JEZWZhdWx0cywgdGhpcy5yZWplY3RPbkRyb3AsIHRoaXMuRXZlbnRzLCB0aGlzLl9zdGF0ZXMsIHRoaXMuUHJvbWlzZSk7XG5cdCAgICAgIGpvYi5wcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJncykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIiA/IGNiKC4uLmFyZ3MpIDogdm9pZCAwO1xuXHQgICAgICB9KS5jYXRjaChmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcblx0ICAgICAgICAgIHJldHVybiB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIiA/IGNiKC4uLmFyZ3MpIDogdm9pZCAwO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIgPyBjYihhcmdzKSA6IHZvaWQgMDtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gdGhpcy5fcmVjZWl2ZShqb2IpO1xuXHQgICAgfVxuXG5cdCAgICBzY2hlZHVsZSguLi5hcmdzKSB7XG5cdCAgICAgIHZhciBqb2IsIG9wdGlvbnMsIHRhc2s7XG5cdCAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgW3Rhc2ssIC4uLmFyZ3NdID0gYXJncztcblx0ICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgW29wdGlvbnMsIHRhc2ssIC4uLmFyZ3NdID0gYXJncztcblx0ICAgICAgfVxuXHQgICAgICBqb2IgPSBuZXcgSm9iJDEodGFzaywgYXJncywgb3B0aW9ucywgdGhpcy5qb2JEZWZhdWx0cywgdGhpcy5yZWplY3RPbkRyb3AsIHRoaXMuRXZlbnRzLCB0aGlzLl9zdGF0ZXMsIHRoaXMuUHJvbWlzZSk7XG5cdCAgICAgIHRoaXMuX3JlY2VpdmUoam9iKTtcblx0ICAgICAgcmV0dXJuIGpvYi5wcm9taXNlO1xuXHQgICAgfVxuXG5cdCAgICB3cmFwKGZuKSB7XG5cdCAgICAgIHZhciBzY2hlZHVsZSwgd3JhcHBlZDtcblx0ICAgICAgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlLmJpbmQodGhpcyk7XG5cdCAgICAgIHdyYXBwZWQgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG5cdCAgICAgICAgcmV0dXJuIHNjaGVkdWxlKGZuLmJpbmQodGhpcyksIC4uLmFyZ3MpO1xuXHQgICAgICB9O1xuXHQgICAgICB3cmFwcGVkLndpdGhPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgLi4uYXJncykge1xuXHQgICAgICAgIHJldHVybiBzY2hlZHVsZShvcHRpb25zLCBmbiwgLi4uYXJncyk7XG5cdCAgICAgIH07XG5cdCAgICAgIHJldHVybiB3cmFwcGVkO1xuXHQgICAgfVxuXG5cdCAgICBhc3luYyB1cGRhdGVTZXR0aW5ncyhvcHRpb25zID0ge30pIHtcblx0ICAgICAgYXdhaXQgdGhpcy5fc3RvcmUuX191cGRhdGVTZXR0aW5nc19fKHBhcnNlciQ1Lm92ZXJ3cml0ZShvcHRpb25zLCB0aGlzLnN0b3JlRGVmYXVsdHMpKTtcblx0ICAgICAgcGFyc2VyJDUub3ZlcndyaXRlKG9wdGlvbnMsIHRoaXMuaW5zdGFuY2VEZWZhdWx0cywgdGhpcyk7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBjdXJyZW50UmVzZXJ2b2lyKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuX19jdXJyZW50UmVzZXJ2b2lyX18oKTtcblx0ICAgIH1cblxuXHQgICAgaW5jcmVtZW50UmVzZXJ2b2lyKGluY3IgPSAwKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5fX2luY3JlbWVudFJlc2Vydm9pcl9fKGluY3IpO1xuXHQgICAgfVxuXG5cdCAgfVxuXHQgIEJvdHRsZW5lY2suZGVmYXVsdCA9IEJvdHRsZW5lY2s7XG5cblx0ICBCb3R0bGVuZWNrLkV2ZW50cyA9IEV2ZW50cyQ0O1xuXG5cdCAgQm90dGxlbmVjay52ZXJzaW9uID0gQm90dGxlbmVjay5wcm90b3R5cGUudmVyc2lvbiA9IHJlcXVpcmUkJDgudmVyc2lvbjtcblxuXHQgIEJvdHRsZW5lY2suc3RyYXRlZ3kgPSBCb3R0bGVuZWNrLnByb3RvdHlwZS5zdHJhdGVneSA9IHtcblx0ICAgIExFQUs6IDEsXG5cdCAgICBPVkVSRkxPVzogMixcblx0ICAgIE9WRVJGTE9XX1BSSU9SSVRZOiA0LFxuXHQgICAgQkxPQ0s6IDNcblx0ICB9O1xuXG5cdCAgQm90dGxlbmVjay5Cb3R0bGVuZWNrRXJyb3IgPSBCb3R0bGVuZWNrLnByb3RvdHlwZS5Cb3R0bGVuZWNrRXJyb3IgPSBCb3R0bGVuZWNrRXJyb3JfMTtcblxuXHQgIEJvdHRsZW5lY2suR3JvdXAgPSBCb3R0bGVuZWNrLnByb3RvdHlwZS5Hcm91cCA9IEdyb3VwXzE7XG5cblx0ICBCb3R0bGVuZWNrLlJlZGlzQ29ubmVjdGlvbiA9IEJvdHRsZW5lY2sucHJvdG90eXBlLlJlZGlzQ29ubmVjdGlvbiA9IHJlcXVpcmUkJDI7XG5cblx0ICBCb3R0bGVuZWNrLklPUmVkaXNDb25uZWN0aW9uID0gQm90dGxlbmVjay5wcm90b3R5cGUuSU9SZWRpc0Nvbm5lY3Rpb24gPSByZXF1aXJlJCQzO1xuXG5cdCAgQm90dGxlbmVjay5CYXRjaGVyID0gQm90dGxlbmVjay5wcm90b3R5cGUuQmF0Y2hlciA9IEJhdGNoZXJfMTtcblxuXHQgIEJvdHRsZW5lY2sucHJvdG90eXBlLmpvYkRlZmF1bHRzID0ge1xuXHQgICAgcHJpb3JpdHk6IERFRkFVTFRfUFJJT1JJVFkkMSxcblx0ICAgIHdlaWdodDogMSxcblx0ICAgIGV4cGlyYXRpb246IG51bGwsXG5cdCAgICBpZDogXCI8bm8taWQ+XCJcblx0ICB9O1xuXG5cdCAgQm90dGxlbmVjay5wcm90b3R5cGUuc3RvcmVEZWZhdWx0cyA9IHtcblx0ICAgIG1heENvbmN1cnJlbnQ6IG51bGwsXG5cdCAgICBtaW5UaW1lOiAwLFxuXHQgICAgaGlnaFdhdGVyOiBudWxsLFxuXHQgICAgc3RyYXRlZ3k6IEJvdHRsZW5lY2sucHJvdG90eXBlLnN0cmF0ZWd5LkxFQUssXG5cdCAgICBwZW5hbHR5OiBudWxsLFxuXHQgICAgcmVzZXJ2b2lyOiBudWxsLFxuXHQgICAgcmVzZXJ2b2lyUmVmcmVzaEludGVydmFsOiBudWxsLFxuXHQgICAgcmVzZXJ2b2lyUmVmcmVzaEFtb3VudDogbnVsbCxcblx0ICAgIHJlc2Vydm9pckluY3JlYXNlSW50ZXJ2YWw6IG51bGwsXG5cdCAgICByZXNlcnZvaXJJbmNyZWFzZUFtb3VudDogbnVsbCxcblx0ICAgIHJlc2Vydm9pckluY3JlYXNlTWF4aW11bTogbnVsbFxuXHQgIH07XG5cblx0ICBCb3R0bGVuZWNrLnByb3RvdHlwZS5sb2NhbFN0b3JlRGVmYXVsdHMgPSB7XG5cdCAgICBQcm9taXNlOiBQcm9taXNlLFxuXHQgICAgdGltZW91dDogbnVsbCxcblx0ICAgIGhlYXJ0YmVhdEludGVydmFsOiAyNTBcblx0ICB9O1xuXG5cdCAgQm90dGxlbmVjay5wcm90b3R5cGUucmVkaXNTdG9yZURlZmF1bHRzID0ge1xuXHQgICAgUHJvbWlzZTogUHJvbWlzZSxcblx0ICAgIHRpbWVvdXQ6IG51bGwsXG5cdCAgICBoZWFydGJlYXRJbnRlcnZhbDogNTAwMCxcblx0ICAgIGNsaWVudFRpbWVvdXQ6IDEwMDAwLFxuXHQgICAgUmVkaXM6IG51bGwsXG5cdCAgICBjbGllbnRPcHRpb25zOiB7fSxcblx0ICAgIGNsdXN0ZXJOb2RlczogbnVsbCxcblx0ICAgIGNsZWFyRGF0YXN0b3JlOiBmYWxzZSxcblx0ICAgIGNvbm5lY3Rpb246IG51bGxcblx0ICB9O1xuXG5cdCAgQm90dGxlbmVjay5wcm90b3R5cGUuaW5zdGFuY2VEZWZhdWx0cyA9IHtcblx0ICAgIGRhdGFzdG9yZTogXCJsb2NhbFwiLFxuXHQgICAgY29ubmVjdGlvbjogbnVsbCxcblx0ICAgIGlkOiBcIjxuby1pZD5cIixcblx0ICAgIHJlamVjdE9uRHJvcDogdHJ1ZSxcblx0ICAgIHRyYWNrRG9uZVN0YXR1czogZmFsc2UsXG5cdCAgICBQcm9taXNlOiBQcm9taXNlXG5cdCAgfTtcblxuXHQgIEJvdHRsZW5lY2sucHJvdG90eXBlLnN0b3BEZWZhdWx0cyA9IHtcblx0ICAgIGVucXVldWVFcnJvck1lc3NhZ2U6IFwiVGhpcyBsaW1pdGVyIGhhcyBiZWVuIHN0b3BwZWQgYW5kIGNhbm5vdCBhY2NlcHQgbmV3IGpvYnMuXCIsXG5cdCAgICBkcm9wV2FpdGluZ0pvYnM6IHRydWUsXG5cdCAgICBkcm9wRXJyb3JNZXNzYWdlOiBcIlRoaXMgbGltaXRlciBoYXMgYmVlbiBzdG9wcGVkLlwiXG5cdCAgfTtcblxuXHQgIHJldHVybiBCb3R0bGVuZWNrO1xuXG5cdH0pLmNhbGwoY29tbW9uanNHbG9iYWwpO1xuXG5cdHZhciBCb3R0bGVuZWNrXzEgPSBCb3R0bGVuZWNrO1xuXG5cdHZhciBsaWIgPSBCb3R0bGVuZWNrXzE7XG5cblx0cmV0dXJuIGxpYjtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bottleneck/light.js\n");

/***/ })

};
;